var documenterSearchIndex = {"docs":
[{"location":"signals/#signals","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"At the heart of Cortex.jl's reactivity system lies the Signal.","category":"page"},{"location":"signals/#Concept","page":"Signals: The Core of Reactivity","title":"Concept","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Think of a Signal as a container for a value that can change over time. The key idea is that other parts of your system can depend on a signal. When the signal's value changes, anything that depends on it (its listeners) is notified, allowing the system to react automatically.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"For Beginners: Imagine a spreadsheet cell. When you change the value in one cell (like A1), other cells that use A1 in their formulas (like B1 = A1 * 2) automatically update. A Signal is like that cell â€“ it holds a value, and changes can trigger updates elsewhere.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"For Advanced Users: Signals form a directed graph (potentially cyclic, although cycles might affect update logic depending on how they are handled). Each Signal node stores a value, an optional type identifier (UInt8), optional metadata, and maintains lists of its dependencies and listeners. When a signal is updated via set_value!, it propagates a notification through the graph, potentially marking downstream signals as 'pending'. This 'pending' state indicates that the signal's value might be stale and needs recomputation. The actual recomputation logic is defined externally via the compute! function, which uses the signal's type and metadata (along with dependency values) to calculate the new value.","category":"page"},{"location":"signals/#Key-Features","page":"Signals: The Core of Reactivity","title":"Key Features","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Value Storage: Holds the current value.\nType Identifier: Stores an optional UInt8 type (get_type), defaulting to 0x00.\nOptional Metadata: Can store arbitrary metadata (get_metadata), defaulting to UndefMetadata().\nDependency Tracking: Knows which other signals it depends on (dependencies) and which signals depend on it (listeners via get_listeners).\nNotification: When updated via set_value!, it notifies its active listeners.\nPending State: Can be marked as is_pending if its dependencies have updated appropriately, signaling a need for recomputation via compute!.\nExternal Computation: Relies on the compute! function and a provided strategy to update its value based on dependencies.\nWeak Dependencies: Supports 'weak' dependencies, which influence the pending state based only on whether they are computed (is_computed), not their age relative to the listener.\nControlled Listening: Allows dependencies to be added without automatically listening to their updates (listen=false in add_dependency!).\nControlled Initial Check: Allows dependencies to be added without immediately checking their computed state (check_computed=false in add_dependency!).","category":"page"},{"location":"signals/#Usage-Examples","page":"Signals: The Core of Reactivity","title":"Usage Examples","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here are some basic examples demonstrating how to use signals.","category":"page"},{"location":"signals/#Creating-Signals-and-Checking-Properties","page":"Signals: The Core of Reactivity","title":"Creating Signals and Checking Properties","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Signals can be created with or without an initial value. You can optionally specify a type identifier and metadata.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Create signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"import Cortex\nusing Test # hide\n\n# Create signals\ns1 = Cortex.Signal(10)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":" # Initial value, computed=true\ns2 = Cortex.Signal(5)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# No initial value, computed=false\ns3 = Cortex.Signal()        ","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Signal with type and metadata\ns4 = Cortex.Signal(true; type=0x01, metadata=Dict(:info => \"flag\"))","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Check their properties:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s1) == 10 # hide\nCortex.get_value(s1)   # 10","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s3) === Cortex.UndefValue() # hide\nCortex.get_value(s3)   # Cortex.UndefValue()","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s1) == true # hide\nCortex.is_computed(s1) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s3) == false # hide\nCortex.is_computed(s3) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_type(s1) === 0x00 # hide\nCortex.get_type(s1) # 0x00 (default)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_type(s4) === 0x01 # hide\nCortex.get_type(s4) # 0x01","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_metadata(s1) === Cortex.UndefMetadata() # hide\nCortex.get_metadata(s1) # UndefMetadata() (default)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_metadata(s4) == Dict(:info => \"flag\") # hide\nCortex.get_metadata(s4) # Dict{Symbol, String}(:info => \"flag\")","category":"page"},{"location":"signals/#Setting-Values","page":"Signals: The Core of Reactivity","title":"Setting Values","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Use Cortex.set_value! to update a signal's value. This marks the signal as computed and updates its age.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Setting a value updates the age and computed status:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.set_value!(s3, 99.0)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s3) == 99.0 # hide\nCortex.get_value(s3)   # 99.0","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s3) == true # hide\nCortex.is_computed(s3) # true","category":"page"},{"location":"signals/#Adding-Dependencies","page":"Signals: The Core of Reactivity","title":"Adding Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Signals can depend on other signals. Use Cortex.add_dependency! to create these links. This populates the dependencies list of the dependent signal and the listeners list of the dependency.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Adding dependencies links signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_derived = Cortex.Signal() # A signal that will depend on s1 and s2\n\nCortex.add_dependency!(s_derived, s1)\nCortex.add_dependency!(s_derived, s2)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_dependencies(s_derived)) == 2 # hide\nlength(Cortex.get_dependencies(s_derived)) # 2","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(s1)) == 1 # hide\nlength(Cortex.get_listeners(s1))           # 1","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(s2)) == 1 # hide\nlength(Cortex.get_listeners(s2))           # 1","category":"page"},{"location":"signals/#Pending-State","page":"Signals: The Core of Reactivity","title":"Pending State","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"A signal becomes pending (Cortex.is_pending returns true) when its dependencies are updated in a way that satisfies the pending criteria (all weak computed, all strong older and computed). Adding a computed dependency can also immediately mark a signal as pending.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Updating a dependency can mark listeners as pending:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_derived) == true # hide\nCortex.is_pending(s_derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_derived is pending because both s1 and s2 have been computed at the time of dependency addition.","category":"page"},{"location":"signals/#Computing-Signal-Values","page":"Signals: The Core of Reactivity","title":"Computing Signal Values","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"To compute a signal, use the Cortex.compute! function, providing a strategy (often a simple function) to calculate the new value based on dependencies. Computing a signal typically clears its pending state.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"note: Note\nBy default, compute! throws an ArgumentError if called on a signal that is not pending (Cortex.is_pending returns false). You can override this check using the force=true keyword argument.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"\nsignal_1 = Cortex.Signal(1)\nsignal_2 = Cortex.Signal(41)\n\nsignal_to_be_computed = Cortex.Signal()\n\nCortex.add_dependency!(signal_to_be_computed, signal_1)\nCortex.add_dependency!(signal_to_be_computed, signal_2)\n\n@test Cortex.is_pending(signal_to_be_computed) == true # hide\nCortex.is_pending(signal_to_be_computed) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Define a strategy (a function) to compute the value\ncompute_sum = (signal, deps) -> sum(Cortex.get_value, deps)\n\n# Apply the strategy using compute!\nCortex.compute!(compute_sum, signal_to_be_computed)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(signal_to_be_computed) == 1 + 41 # hide\nCortex.get_value(signal_to_be_computed) # 42","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(signal_to_be_computed) == false # hide\nCortex.is_pending(signal_to_be_computed) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# This would normally throw an error:\n# compute!(compute_sum, signal_to_be_computed)\n\n# But we can force it:\nCortex.compute!(compute_sum, signal_to_be_computed; force=true)\n\n@test Cortex.get_value(signal_to_be_computed) == 42 # hide (value unchanged as deps are same)\nCortex.get_value(signal_to_be_computed) # 42","category":"page"},{"location":"signals/#Custom-Compute-Strategies","page":"Signals: The Core of Reactivity","title":"Custom Compute Strategies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"You can define custom types and methods to implement more complex computation logic beyond simple functions. This allows strategies to hold their own state or parameters.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"First, define a struct for your strategy:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"struct CustomStrategy\n    multiplier::Int\nend","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Then, implement the Cortex.compute_value! method for your strategy type:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"function Cortex.compute_value!(strategy::CustomStrategy, signal::Cortex.Signal, dependencies)\n    # Example: Use signal's metadata if available\n    meta = Cortex.get_metadata(signal)\n    base_sum = sum(Cortex.get_value, dependencies)\n    offset = meta isa Dict && haskey(meta, :offset) ? meta[:offset] : 0\n    return strategy.multiplier * base_sum + offset\nend","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Now, you can use this strategy with your signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"strategy = CustomStrategy(2)\n\nsignal_with_meta = Cortex.Signal(metadata=Dict(:offset => 10))\n\nCortex.add_dependency!(signal_with_meta, signal_1)\nCortex.add_dependency!(signal_with_meta, signal_2)\n@test Cortex.is_pending(signal_with_meta) # hide\n\nCortex.compute!(strategy, signal_with_meta)\n\n@test Cortex.get_value(signal_with_meta) == 2 * (1 + 41) + 10 # hide\nCortex.get_value(signal_with_meta) # 94","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.compute!(CustomStrategy(3), signal_with_meta; force=true)\n\n@test Cortex.get_value(signal_with_meta) == 3 * (1 + 41) + 10 # hide\nCortex.get_value(signal_with_meta) # 136","category":"page"},{"location":"signals/#Non-Listening-Dependencies","page":"Signals: The Core of Reactivity","title":"Non-Listening Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Using listen=false in Cortex.add_dependency! creates a dependency relationship, but prevents the dependent signal from being automatically notified (and potentially marked pending) when the dependency's value changes.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Using listen=false creates a dependency without automatic notifications:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_source = Cortex.Signal()\ns_non_listener = Cortex.Signal()\n\nCortex.add_dependency!(s_non_listener, s_source; listen=false)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Update s_source. s_non_listener is NOT notified.\nCortex.set_value!(s_source, 6)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/#API-Reference","page":"Signals: The Core of Reactivity","title":"API Reference","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here is the detailed API documentation for the Signal type and its associated functions:","category":"page"},{"location":"signals/#Cortex.UndefValue","page":"Signals: The Core of Reactivity","title":"Cortex.UndefValue","text":"UndefValue\n\nA singleton type used to represent an undefined or uninitialized state within a Signal. This indicates that the signal has not yet been computed or has been invalidated.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.UndefMetadata","page":"Signals: The Core of Reactivity","title":"Cortex.UndefMetadata","text":"UndefMetadata\n\nA singleton type used to represent undefined metadata within a Signal.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.Signal","page":"Signals: The Core of Reactivity","title":"Cortex.Signal","text":"Signal()\nSignal(value; type::UInt8 = 0x00, metadata::Any = UndefMetadata())\n\nA reactive signal that holds a value and tracks dependencies as well as notifies listeners when the value changes. If created without an initial value, the signal is initialized with UndefValue().\n\nA signal is said to be 'pending' if it is ready for potential recomputation (due to updated dependencies). However, a signal is not recomputed immediately when it becomes pending. Moreover, a Signal does not know  how to recompute itself. The recomputation logic is defined separately with the compute! function.\n\nSignals form a directed graph where edges represent dependencies. When a signal's value is updated via set_value!, it notifies its active listeners.\n\nA signal may become 'pending' if all its dependencies meet the following criteria:\n\nall its weak dependencies have computed values, AND\nall its strong dependencies have computed values and are older than the listener.\n\nA signal can depend on another signal without listening to it, see add_dependency! for more details.\n\nSee also:\n\nadd_dependency!: Establishes a dependency relationship between signals.\nset_value!: Updates the signal's value and notifies listeners.\ncompute!: Function responsible for recomputing a signal's value.\nis_pending: Checks if the signal is marked for potential recomputation.\nis_computed: Checks if the signal currently holds a computed value (not UndefValue).\nget_value: Retrieves the current value stored in the signal.\nget_type: Retrieves the type identifier of the signal.\nget_metadata: Retrieves the metadata associated with the signal.\nget_age: Gets the computation age of the signal.\nget_dependencies: Returns the list of signals this signal depends on.\nget_listeners: Returns the list of signals that listen to this signal.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.is_pending-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_pending","text":"is_pending(s::Signal) -> Bool\n\nCheck if the signal s is marked as pending.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.is_computed-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_computed","text":"is_computed(s::Signal) -> Bool\n\nCheck if the signal s has been computed (i.e., its value has been set at least once). This is determined by checking if get_age(s) > 0.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_value-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_value","text":"get_value(s::Signal)\n\nGet the current value of the signal s.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_type-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_type","text":"get_type(s::Signal) -> UInt8\n\nGet the type identifier (UInt8) of the signal s. Defaults to 0x00 if not specified during construction.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_metadata-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_metadata","text":"get_metadata(s::Signal)\n\nGet the metadata associated with the signal s. Defaults to UndefMetadata() if not specified during construction.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_age-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_age","text":"get_age(s::Signal) -> UInt64\n\nGet the current age of the signal s. The age increments each time set_value! is called.  However, the amount of the increment is not fixed and should not be relied upon.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_dependencies-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_dependencies","text":"get_dependencies(s::Signal) -> Vector{Signal}\n\nGet the list of signals that the signal s depends on.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_listeners-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_listeners","text":"get_listeners(s::Signal) -> Vector{Signal}\n\nGet the list of signals that listen to the signal s (i.e., signals that depend on s).\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.set_value!-Tuple{Cortex.Signal, Any}","page":"Signals: The Core of Reactivity","title":"Cortex.set_value!","text":"set_value!(s::Signal, value::Any)\n\nSet the value of the signal s. Notifies all the active listeners of the signal. Some of the active listeners might become pending.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.add_dependency!","text":"add_dependency!(signal::Signal, dependency::Signal; weak::Bool = false, listen::Bool = true)\n\nAdd dependency to the list of dependencies for signal signal. Also adds signal to the list of listeners for dependency.\n\nArguments:\n\nsignal::Signal: The signal to add a dependency to.\ndependency::Signal: The signal to be added as a dependency.\n\nKeyword Arguments:\n\nweak::Bool = false: If true, marks the dependency as weak. Weak dependencies only require is_computed to be true (not necessarily older) for the dependent signal signal to potentially become pending.\nlisten::Bool = true: If true, signal will be notified when dependency is updated. If false, dependency is added, but signal will not automatically be notified of updates to dependency.\ncheck_computed::Bool = true: If true, the function will check if dependency is already computed.\n\nIf so, it will notify signal immediately. Note that if listen is set to false,  further updates to dependency will not trigger notifications to signal.\n\nNote that this function does nothing if signal === dependency.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.compute!-Tuple{Any, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.compute!","text":"compute!(s::Signal, strategy; force::Bool = false)\n\nCompute the value of the signal s using the given strategy.  The strategy must implement compute_value! method. If the strategy is a function, it is assumed to be a function that takes the signal and a vector of signal's dependencies as arguments and returns a value. Be sure to call compute! only on signals that are pending.  Calling compute! on a non-pending signal will result in an error.\n\nKeyword Arguments:\n\nforce::Bool = false: If true, the signal will be computed even if it is not pending.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}","page":"Signals: The Core of Reactivity","title":"Cortex.compute_value!","text":"compute_value!(strategy, signal, dependencies)\n\nCompute the value of the signal signal using the given strategy. The strategy must implement this method. See also compute!.\n\n\n\n\n\n","category":"method"},{"location":"#Cortex","page":"Home","title":"Cortex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cortex. Cortex is a simple, efficient and modular framework for running message passing algorithms on graphs, with a focus on message-passing based Bayesian inference. This is a successor to the ReactiveMP.jl package.","category":"page"},{"location":"#Where-To-Go-Next?","page":"Home","title":"Where To Go Next?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Signals - Read about core reactive programming concepts with the Signal type.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
