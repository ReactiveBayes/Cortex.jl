var documenterSearchIndex = {"docs":
[{"location":"signals/#signals","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"At the heart of Cortex.jl's reactivity system lies the Signal.","category":"page"},{"location":"signals/#Concept","page":"Signals: The Core of Reactivity","title":"Concept","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Think of a Cortex.Signal as a container for a value that can change over time. The key idea is that other parts of your system can depend on a signal. When the signal's value changes, anything that depends on it (its listeners) is notified, allowing the system to react automatically.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"For Beginners: Imagine a spreadsheet cell. When you change the value in one cell (like A1), other cells that use A1 in their formulas (like B1 = A1 * 2) automatically update. A Cortex.Signal is like that cell â€“ it holds a value, and changes can trigger updates elsewhere.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"For Advanced Users: Signals form a directed graph (potentially cyclic, although cycles might affect update logic depending on how they are handled). Each Cortex.Signal node stores a value and maintains lists of its dependencies (signals it reads from) and listeners (signals that read from it). When a signal is updated via Cortex.set_value!, it propagates a notification through the graph, potentially marking downstream signals as 'pending'. This 'pending' state indicates that the signal's value might be stale and needs recomputation. The actual recomputation logic, however, is typically managed by a higher-level construct like a Slot (assuming Slot is documented elsewhere, otherwise keep as Slot or add its reference if available), which observes the pending state.","category":"page"},{"location":"signals/#Key-Features","page":"Signals: The Core of Reactivity","title":"Key Features","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Value Storage: Holds the current value.\nDependency Tracking: Knows which other signals it depends on (dependencies) and which signals depend on it listeners via Cortex.get_listeners.\nNotification: When updated via Cortex.set_value!, it notifies its active listeners.\nPending State: Can be marked as Cortex.is_pending if its dependencies have updated appropriately, signaling a need for potential recomputation.\nWeak Dependencies: Supports 'weak' dependencies, which influence the pending state based only on whether they are computed (Cortex.is_computed), not their age relative to the listener.\nControlled Listening: Allows dependencies to be added without automatically listening to their updates (listen=false in Cortex.add_dependency!).\nControlled Initial Check: Allows dependencies to be added without immediately checking their computed state (check_computed=false in Cortex.add_dependency!).","category":"page"},{"location":"signals/#Usage-Examples","page":"Signals: The Core of Reactivity","title":"Usage Examples","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here are some basic examples demonstrating how to use signals.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Create signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"import Cortex\nusing Test # hide\n\n# Create signals\ns1 = Cortex.Signal(10)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":" # Initial value, computed=true\ns2 = Cortex.Signal(\"hello\")","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# No initial value, computed=false\ns3 = Cortex.Signal()        ","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Check their properties:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s1) == 10 # hide\nCortex.get_value(s1)   # 10","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s3) === Cortex.UndefValue() # hide\nCortex.get_value(s3)   # Cortex.UndefValue()","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s1) == true # hide\nCortex.is_computed(s1) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s3) == false # hide\nCortex.is_computed(s3) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Setting a value updates the age and computed status:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.set_value!(s3, 99.0)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s3) == 99.0 # hide\nCortex.get_value(s3)   # 99.0","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s3) == true # hide\nCortex.is_computed(s3) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Adding dependencies links signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_derived = Cortex.Signal() # A signal that will depend on s1 and s2\n\nCortex.add_dependency!(s_derived, s1)\nCortex.add_dependency!(s_derived, s2)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_dependencies(s_derived)) == 2 # hide\nlength(Cortex.get_dependencies(s_derived)) # 2","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(s1)) == 1 # hide\nlength(Cortex.get_listeners(s1))           # 1","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(s2)) == 1 # hide\nlength(Cortex.get_listeners(s2))           # 1","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Updating a dependency can mark listeners as pending:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_derived) == true # hide\nCortex.is_pending(s_derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_derived is pending because both s1 and s2 have been computed at the time of dependency addition.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Using listen=false creates a dependency without automatic notifications:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_source = Cortex.Signal()\ns_non_listener = Cortex.Signal()\n\nCortex.add_dependency!(s_non_listener, s_source; listen=false)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Update s_source. s_non_listener is NOT notified.\nCortex.set_value!(s_source, 6)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/#API-Reference","page":"Signals: The Core of Reactivity","title":"API Reference","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here is the detailed API documentation for the Signal type and its associated functions:","category":"page"},{"location":"signals/#Cortex.UndefValue","page":"Signals: The Core of Reactivity","title":"Cortex.UndefValue","text":"UndefValue\n\nA singleton type used to represent an undefined or uninitialized state within a Signal. This indicates that the signal has not yet been computed or has been invalidated.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.Signal","page":"Signals: The Core of Reactivity","title":"Cortex.Signal","text":"Signal()\nSignal(value)\n\nA reactive signal that holds a value and tracks dependencies as well as notifies listeners when the value changes. If created without an initial value, the signal is initialized with UndefValue().\n\nA signal is said to be 'pending' if it is ready for potential recomputation (due to updated dependencies). However, a signal is not recomputed immediately when it becomes pending. Moreover, a Signal does not know  how to recompute itself. This is a responsibility of the Slot type.\n\nSignals form a directed graph where edges represent dependencies. When a signal's value is updated via set_value!, it notifies its active listeners.\n\nA signal may become 'pending' if all its dependencies meet the following criteria:\n\nall its weak dependencies have computed values, AND\nall its strong dependencies have computed values and are older than the listener.\n\nA signal can depend on another signal without listening to it, see add_dependency! for more details.\n\nSee also:\n\nSlot: Manages signal recomputation logic.\nadd_dependency!: Establishes a dependency relationship between signals.\nset_value!: Updates the signal's value and notifies listeners.\nis_pending: Checks if the signal is marked for potential recomputation.\nis_computed: Checks if the signal currently holds a computed value (not UndefValue).\nget_value: Retrieves the current value stored in the signal.\nget_age: Gets the computation age of the signal.\nget_dependencies: Returns the list of signals this signal depends on.\nget_listeners: Returns the list of signals that listen to this signal.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.is_pending-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_pending","text":"is_pending(s::Signal) -> Bool\n\nCheck if the signal s is marked as pending.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.is_computed-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_computed","text":"is_computed(s::Signal) -> Bool\n\nCheck if the signal s has been computed (i.e., its value has been set at least once). This is determined by checking if get_age(s) > 0.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_value-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_value","text":"get_value(s::Signal)\n\nGet the current value of the signal s.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_age-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_age","text":"get_age(s::Signal) -> UInt64\n\nGet the current age of the signal s. The age increments each time set_value! is called.  However, the amount of the increment is not fixed and should not be relied upon.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_dependencies-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_dependencies","text":"get_dependencies(s::Signal) -> Vector{Signal}\n\nGet the list of signals that the signal s depends on.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_listeners-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_listeners","text":"get_listeners(s::Signal) -> Vector{Signal}\n\nGet the list of signals that listen to the signal s (i.e., signals that depend on s).\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.set_value!-Tuple{Cortex.Signal, Any}","page":"Signals: The Core of Reactivity","title":"Cortex.set_value!","text":"set_value!(s::Signal, value::Any)\n\nSet the value of the signal s. Notifies all the active listeners of the signal. Some of the active listeners might become pending.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.add_dependency!","text":"add_dependency!(signal::Signal, dependency::Signal; weak::Bool = false, listen::Bool = true)\n\nAdd dependency to the list of dependencies for signal signal. Also adds signal to the list of listeners for dependency.\n\nArguments:\n\nsignal::Signal: The signal to add a dependency to.\ndependency::Signal: The signal to be added as a dependency.\n\nKeyword Arguments:\n\nweak::Bool = false: If true, marks the dependency as weak. Weak dependencies only require is_computed to be true (not necessarily older) for the dependent signal signal to potentially become pending.\nlisten::Bool = true: If true, signal will be notified when dependency is updated. If false, dependency is added, but signal will not automatically be notified of updates to dependency.\ncheck_computed::Bool = true: If true, the function will check if dependency is already computed.\n\nIf so, it will notify signal immediately. Note that if listen is set to false,  further updates to dependency will not trigger notifications to signal.\n\nNote that this function does nothing if signal === dependency.\n\n\n\n\n\n","category":"method"},{"location":"#Cortex","page":"Home","title":"Cortex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cortex. Cortex is a simple, efficient and modular framework for running message passing algorithms on graphs, with a focus on message-passing based Bayesian inference. This is a successor to the ReactiveMP.jl package.","category":"page"},{"location":"#Where-To-Go-Next?","page":"Home","title":"Where To Go Next?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Signals - Read about core reactive programming concepts with the Signal type.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
