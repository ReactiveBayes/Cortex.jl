var documenterSearchIndex = {"docs":
[{"location":"implementation/value/#Value","page":"Value","title":"Value","text":"","category":"section"},{"location":"implementation/value/","page":"Value","title":"Value","text":"The Value type is a mutable struct that holds a value and metadata about the value.","category":"page"},{"location":"implementation/value/#Cortex.Value","page":"Value","title":"Cortex.Value","text":"Value([ value ])\n\nA data structure that can hold any value.  Additionally, holds metadata about the value, such as\n\nis_pending: whether the value can be updated\nis_computed: whether the value has been computed and can be accessed\n\nIf the value is not yet computed, it is represented as UndefValue().\n\nSee also: is_pending, is_computed\n\n\n\n\n\n","category":"type"},{"location":"implementation/value/#Cortex.is_pending","page":"Value","title":"Cortex.is_pending","text":"is_pending(value::Value)\n\nReturns true if the value is pending, false otherwise.\n\nSee also: is_computed\n\n\n\n\n\n","category":"function"},{"location":"implementation/value/#Cortex.is_computed","page":"Value","title":"Cortex.is_computed","text":"is_computed(value::Value)\n\nReturns true if the value has been computed, false otherwise.\n\nSee also: is_pending\n\n\n\n\n\n","category":"function"},{"location":"implementation/value/","page":"Value","title":"Value","text":"The primary purpose of the Value type is to hold the result of a message and marginal computations.  The inference engine will use the metadata to determine if the value is pending and must be re-computed. Both messages and marginals use the Value type to hold their result either along edges of the graph or at the nodes of the graph.","category":"page"},{"location":"implementation/value/#Cortex.set_pending!-Tuple{Cortex.Value}","page":"Value","title":"Cortex.set_pending!","text":"set_pending!(value::Value)\n\nSets the value to pending.\n\nSee also: is_pending, is_computed\n\n\n\n\n\n","category":"method"},{"location":"implementation/value/#Cortex.unset_pending!-Tuple{Cortex.Value}","page":"Value","title":"Cortex.unset_pending!","text":"unset_pending!(value::Value)\n\nUnsets the pending status of the value.\n\nSee also: set_pending!, is_pending\n\n\n\n\n\n","category":"method"},{"location":"implementation/value/#Cortex.set_value!-Tuple{Cortex.Value, Any}","page":"Value","title":"Cortex.set_value!","text":"set_value!(value::Value, value)\n\nSets the value of the value.\n\nSee also: is_pending, is_computed\n\n\n\n\n\n","category":"method"},{"location":"implementation/value/#Cortex.UndefValue","page":"Value","title":"Cortex.UndefValue","text":"UndefValue\n\nA placeholder value that represents a value that is not yet computed.\n\n\n\n\n\n","category":"type"},{"location":"implementation/value/#DualPendingGroup","page":"Value","title":"DualPendingGroup","text":"","category":"section"},{"location":"implementation/value/","page":"Value","title":"Value","text":"The DualPendingGroup type is a helper struct that is used to track the pending state of a value. It is used to optimize the computation of the pending state of a collection of values by using a bitwise operation.","category":"page"},{"location":"implementation/value/#Cortex.DualPendingGroup","page":"Value","title":"Cortex.DualPendingGroup","text":"DualPendingGroup\n\nA data structure designed to efficiently track and manage dual pending states in a message-passing style system.\n\nConcept\n\nEach value in the group maintains two distinct pending states:\n\nInbound pending: directly set from outside (like receiving a message)\nOutbound pending: automatically determined based on other values' states (like sending a message)\n\nBehavior\n\nThe dual pending states follow these rules:\n\nInbound pending is explicitly set for each value\nOutbound pending for a value becomes true when ALL OTHER values are inbound pending\nA value's outbound state cannot be directly set, it is derived from others' inbound states\n\nExample\n\nConsider a group of 3 values [A, B, C] with their states as (inbound, outbound):\n\nInitial: \nA: (false, false), B: (false, false), C: (false, false)\n\nSet A and B inbound pending:\nA: (true, false), B: (true, false), C: (false, true)\n\nSet C inbound pending:\nA: (true, true), B: (true, true), C: (true, true)\n\nThis structure is particularly useful in message-passing algorithms where each node needs to track both  incoming and outgoing message states, similar to variable nodes in factor graphs.\n\n\n\n\n\n","category":"type"},{"location":"implementation/value/#Cortex.is_pending_in","page":"Value","title":"Cortex.is_pending_in","text":"is_pending_in(dpg::DualPendingGroup, i::Int)\n\nCheck if the value at index i has its inbound pending state set.\n\n\n\n\n\n","category":"function"},{"location":"implementation/value/#Cortex.is_pending_out","page":"Value","title":"Cortex.is_pending_out","text":"is_pending_out(dpg::DualPendingGroup, i::Int)\n\nCheck if the value at index i has its outbound pending state set. The outbound state is true when all other values are inbound pending.\n\n\n\n\n\n","category":"function"},{"location":"implementation/value/#Cortex.set_pending!-Tuple{Cortex.DualPendingGroup, Int64}","page":"Value","title":"Cortex.set_pending!","text":"set_pending!(dpg::DualPendingGroup, i::Int)\n\nSet the inbound pending state for value i and update outbound states accordingly. When a value is set to inbound pending, we need to check if this causes any other values to become outbound pending (when all their other values are inbound pending).\n\n\n\n\n\n","category":"method"},{"location":"implementation/value/#Cortex.add_element!-Tuple{Cortex.DualPendingGroup}","page":"Value","title":"Cortex.add_element!","text":"add_element!(dpg::DualPendingGroup)\n\nAdd a new element to the DualPendingGroup. The new element is initialized with all pending states set to false. Returns the index of the newly added element.\n\n\n\n\n\n","category":"method"},{"location":"#Cortex","page":"Home","title":"Cortex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cortex. Cortex is a simple, efficient and modular framework for running message passing algorithms on graphs, with a focus on message-passing based Bayesian inference. This is a successor to the ReactiveMP.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
