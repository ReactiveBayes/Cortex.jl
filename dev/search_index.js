var documenterSearchIndex = {"docs":
[{"location":"signals/#signals","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"At the heart of Cortex.jl's reactivity system lies the Signal.","category":"page"},{"location":"signals/#Concept","page":"Signals: The Core of Reactivity","title":"Concept","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Think of a Signal as a container for a value that can change over time. The key idea is that other parts of your system can depend on a signal. When the signal's value changes, anything that depends on it (its listeners) is notified, allowing the system to react on changes and recompute values.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Imagine a spreadsheet cell. When you change the value in one cell (like A1), other cells that use A1 in their formulas (like B1 = A1 * 2) automatically update. A Signal is like that cell â€“ it holds a value, and changes can trigger updates elsewhere.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"More technically, Signals form a directed graph (potentially cyclic). Each Signal node stores a value, an optional type identifier (UInt8), optional metadata, and maintains lists of its dependencies and listeners. When a signal is updated via set_value!, it propagates a notification to its direct listeners, potentially marking them as 'pending'. This 'pending' state indicates that the signal's value might be stale and needs recomputation. The actual recomputation logic is defined externally via the compute! function. A signal may become 'pending' if all its dependencies meet the criteria: weak dependencies are computed, and strong dependencies are computed and fresh (i.e., have new, unused values). This also means that a signal never recomputes its own value, as it must be done externally.","category":"page"},{"location":"signals/#Key-Features","page":"Signals: The Core of Reactivity","title":"Key Features","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Value Storage: Holds the current value.\nType Identifier: Stores an optional UInt8 type (get_type), defaulting to 0x00. This might be particularly useful for choosing different computation strategies for different types of signals within the compute! function.\nOptional Metadata: Can store arbitrary metadata (get_metadata), defaulting to UndefMetadata().\nDependency Tracking: Knows which other signals it depends on (dependencies) and which signals depend on it (see  get_listeners).\nNotification: When updated via set_value!, it notifies its active listeners.\nPending State: Can be marked as is_pending if its dependencies have updated appropriately, signaling a need for recomputation via compute!.\nExternal Computation: Relies on the compute! function and a provided strategy to update its value based on dependencies.\nWeak Dependencies: Supports 'weak' dependencies, which influence the pending state based only on whether they are computed (is_computed), not their 'fresh' status in the same way as strong dependencies. See add_dependency! for more details.\nControlled Listening: Allows dependencies to be added without automatically listening to their updates (listen=false in add_dependency!).","category":"page"},{"location":"signals/#Cortex.Signal","page":"Signals: The Core of Reactivity","title":"Cortex.Signal","text":"Signal()\nSignal(value; type::UInt8 = 0x00, metadata::Any = UndefMetadata())\n\nA reactive signal that holds a value and tracks dependencies as well as notifies listeners when the value changes. If created without an initial value, the signal is initialized with UndefValue(). The metadata field can be used to store arbitrary metadata about the signal. Default value is UndefMetadata().\n\nA signal is said to be 'pending' if it is ready for potential recomputation (due to updated dependencies). However, a signal is not recomputed immediately when it becomes pending. Moreover, a Signal does not know  how to recompute itself. The recomputation logic is defined separately with the compute! function.\n\nSignals form a directed graph where edges represent dependencies. When a signal's value is updated via set_value!, it notifies its active listeners.\n\nA signal may become 'pending' if all its dependencies meet the following criteria:\n\nall its weak dependencies have computed values, AND\nall its strong dependencies have computed values and are older than the listener.\n\nA signal can depend on another signal without listening to it, see add_dependency! for more details.\n\nThe type field is an optional UInt8 type identifier.  It might be useful to choose different computation strategies for different types of signals within the compute! function.\n\nSee also: add_dependency!, set_value!, compute!, process_dependencies!\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.UndefValue","page":"Signals: The Core of Reactivity","title":"Cortex.UndefValue","text":"UndefValue\n\nA singleton type used to represent an undefined or uninitialized state within a Signal. This indicates that the signal has not yet been computed or has been invalidated.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Cortex.UndefMetadata","page":"Signals: The Core of Reactivity","title":"Cortex.UndefMetadata","text":"UndefMetadata\n\nA singleton type used to represent an undefined or uninitialized state within a Signal. This indicates that the signal has no metadata.\n\n\n\n\n\n","category":"type"},{"location":"signals/#Core-Operations","page":"Signals: The Core of Reactivity","title":"Core Operations","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here are some basic examples demonstrating how to use signals.","category":"page"},{"location":"signals/#Creating-Signals-and-Checking-Properties","page":"Signals: The Core of Reactivity","title":"Creating Signals and Checking Properties","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Signals can be created with or without an initial value. You can optionally specify a type identifier and metadata.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"import Cortex\nusing Test # hide\n\n# Create signals\ns1 = Cortex.Signal(10)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":" # Initial value, computed=true\ns2 = Cortex.Signal(5)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# No initial value, computed=false\ns3 = Cortex.Signal()        ","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Signal with type and metadata\ns4 = Cortex.Signal(true; type=0x01, metadata=Dict(:info => \"flag\"))","category":"page"},{"location":"signals/#Checking-Properties-of-Signals","page":"Signals: The Core of Reactivity","title":"Checking Properties of Signals","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s1) == 10 # hide\nCortex.get_value(s1)   # 10","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(s3) === Cortex.UndefValue() # hide\nCortex.get_value(s3)   # Cortex.UndefValue()","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s1) == true # hide\nCortex.is_computed(s1) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(s3) == false # hide\nCortex.is_computed(s3) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_type(s1) === 0x00 # hide\nCortex.get_type(s1) # 0x00 (default)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_type(s4) === 0x01 # hide\nCortex.get_type(s4) # 0x01","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_metadata(s1) === Cortex.UndefMetadata() # hide\nCortex.get_metadata(s1) # UndefMetadata() (default)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_metadata(s4) == Dict(:info => \"flag\") # hide\nCortex.get_metadata(s4) # Dict{Symbol, String}(:info => \"flag\")","category":"page"},{"location":"signals/#Cortex.get_value-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_value","text":"get_value(s::Signal)\n\nGet the current value of the signal s.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_type-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_type","text":"get_type(s::Signal) -> UInt8\n\nGet the type identifier (UInt8) of the signal s. Defaults to 0x00 if not specified during construction.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_metadata-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_metadata","text":"get_metadata(s::Signal)\n\nGet the metadata associated with the signal s.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.is_computed-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_computed","text":"is_computed(s::Signal) -> Bool\n\nCheck if the signal s has been computed (i.e., its value is not equal to UndefValue()). See also: set_value!.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.is_pending-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.is_pending","text":"is_pending(s::Signal) -> Bool\n\nCheck if the signal s is marked as pending. This usually indicates that the signal's value is stale and needs recomputation. See also: compute!, process_dependencies!.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Adding-Dependencies","page":"Signals: The Core of Reactivity","title":"Adding Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Signals can depend on other signals. Use add_dependency! to create these links. This populates the dependencies list of the dependent signal and the listeners list of the dependency.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"source_1 = Cortex.Signal(1)\nsource_2 = Cortex.Signal(2)\n\nderived = Cortex.Signal() # A signal that will depend on s1 and s2\n\nCortex.add_dependency!(derived, source_1)\nCortex.add_dependency!(derived, source_2)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_dependencies(derived)) == 2 # hide\nlength(Cortex.get_dependencies(derived)) # 2","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(source_1)) == 1 # hide\nlength(Cortex.get_listeners(source_1))           # 1","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test length(Cortex.get_listeners(source_2)) == 1 # hide\nlength(Cortex.get_listeners(source_2))           # 1","category":"page"},{"location":"signals/#Types-of-Dependencies","page":"Signals: The Core of Reactivity","title":"Types of Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex supports different types of dependencies through options in add_dependency!:","category":"page"},{"location":"signals/#Strong-vs.-Weak-Dependencies","page":"Signals: The Core of Reactivity","title":"Strong vs. Weak Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"By default, dependencies are \"strong,\" meaning they must be both computed and fresh (recently updated) for a signal to become pending. With weak=true, a dependency only needs to be computed (not necessarily fresh) to contribute to the pending state.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"weak_dependency = Cortex.Signal(1)\nstrong_dependency = Cortex.Signal(2)\n\nderived = Cortex.Signal(3)\n\nCortex.add_dependency!(derived, weak_dependency; weak=true)\nCortex.add_dependency!(derived, strong_dependency)\n\n@test Cortex.is_pending(derived) == false # hide\nCortex.is_pending(derived) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.set_value!(strong_dependency, 10)\n\n@test Cortex.is_pending(derived) == true # hide\nCortex.is_pending(derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Here, even though weak_dependency has not been updated, derived is still in the pending state because it only needs strong_dependency to be updated and weak_dependency only needs to be computed once (or set via constructor).","category":"page"},{"location":"signals/#Listening-vs.-Non-listening-Dependencies","page":"Signals: The Core of Reactivity","title":"Listening vs. Non-listening Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"With listen=true (default), a signal is notified when its dependency changes. Setting listen=false creates a dependency relationship without automatic notifications, useful when you want to manually control when a signal responds to changes.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"s_source = Cortex.Signal()\ns_non_listener = Cortex.Signal()\n\nCortex.add_dependency!(s_non_listener, s_source; listen=false)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Update s_source. s_non_listener is NOT notified.\nCortex.set_value!(s_source, 6)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(s_non_listener) == false # hide\nCortex.is_pending(s_non_listener) # false","category":"page"},{"location":"signals/#Intermediate-Dependencies","page":"Signals: The Core of Reactivity","title":"Intermediate Dependencies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Setting intermediate=true marks a dependency as intermediate, which affects how process_dependencies! traverses the dependency graph. This is useful for complex dependency trees where some nodes serve as connectors between different parts of the graph.","category":"page"},{"location":"signals/#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.add_dependency!","text":"add_dependency!(signal::Signal, dependency::Signal; weak::Bool = false, listen::Bool = true, intermediate::Bool = false)\n\nAdd dependency to the list of dependencies for signal signal. Also adds signal to the list of listeners for dependency.\n\nArguments:\n\nsignal::Signal: The signal to add a dependency to.\ndependency::Signal: The signal to be added as a dependency.\n\nKeyword Arguments:\n\nintermediate::Bool = false: If true, marks the dependency as intermediate. Intermediate dependencies\n\nhave an effect on the process_dependencies! function. See the documentation of process_dependencies! for more details. By default, the added dependency is not intermediate.\n\nweak::Bool = false: If true, marks the dependency as weak. Weak dependencies only require is_computed to be true (not necessarily older) for the dependent signal signal to potentially become pending.\nlisten::Bool = true: If true, signal will be notified when dependency is updated. If false, dependency is added, but signal will not automatically be notified of updates to dependency.\ncheck_computed::Bool = true: If true, the function will check if dependency is already computed.\n\nIf so, it will notify signal immediately. Note that if listen is set to false,  further updates to dependency will not trigger notifications to signal.\n\nThe same dependency should not be added multiple times. Doing so will result in wrong notification behaviour and likely will lead to incorrect results. Note that this function does nothing if signal === dependency.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_dependencies-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_dependencies","text":"get_dependencies(s::Signal) -> Vector{Signal}\n\nGet the list of signals that the signal s depends on.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.get_listeners-Tuple{Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.get_listeners","text":"get_listeners(s::Signal) -> Vector{Signal}\n\nGet the list of signals that listen to the signal s (i.e., signals that depend on s).\n\n\n\n\n\n","category":"method"},{"location":"signals/#Pending-State","page":"Signals: The Core of Reactivity","title":"Pending State","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"A signal becomes pending (is_pending returns true) when its dependencies are updated in a way that satisfies the pending criteria (all weak dependencies are computed, and all strong dependencies are fresh and computed). Adding a computed dependency can also immediately mark a signal as pending.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Updating a dependency can mark listeners as pending:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"source_1 = Cortex.Signal(1)\nsource_2 = Cortex.Signal(2)\n\nderived = Cortex.Signal() # A signal that will depend on s1 and s2\n\nCortex.add_dependency!(derived, source_1)\nCortex.add_dependency!(derived, source_2)\n\n@test Cortex.is_pending(derived) == true # hide\nCortex.is_pending(derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"derived is pending because both source_1 and source_2 have been computed and are considered fresh with respect to derived at the time of dependency addition. Let's try a different example:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"uncomputed_source = Cortex.Signal()\nderived = Cortex.Signal()\n\nCortex.add_dependency!(derived, uncomputed_source)\n\n@test Cortex.is_pending(derived) == false # hide\nCortex.is_pending(derived) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.set_value!(uncomputed_source, 1)\n\n@test Cortex.is_pending(derived) == true # hide\nCortex.is_pending(derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"After setting the value of uncomputed_source, derived becomes pending because uncomputed_source is now computed and fresh with respect to derived.","category":"page"},{"location":"signals/#Setting-Values","page":"Signals: The Core of Reactivity","title":"Setting Values","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Use set_value! to update a signal's value. It also consumes the 'freshness' of its own dependencies and updates the 'fresh' and 'computed' status for its listeners, potentially marking them as pending.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"note: Note\nNormally, it is implied that set_value! must be called only on signals that are pending. Also see the compute! function for a more general way to update signal values.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"source  = Cortex.Signal(1)\nderived = Cortex.Signal()\n\nCortex.add_dependency!(derived, source)\n\n@test Cortex.is_pending(derived) == true #hide\nCortex.is_pending(derived), Cortex.is_computed(derived)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.set_value!(derived, 99.0)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(derived) == 99.0 # hide\nCortex.get_value(derived)   # 99.0","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_computed(derived) == true # hide\n@test Cortex.is_pending(derived) == false # hide\nCortex.is_pending(derived), Cortex.is_computed(derived) # false, true","category":"page"},{"location":"signals/#Cortex.set_value!-Tuple{Cortex.Signal, Any}","page":"Signals: The Core of Reactivity","title":"Cortex.set_value!","text":"set_value!(s::Signal, value::Any)\n\nSet the value of the signal s. Notifies all the active listeners of the signal.\n\nnote: Note\nThis function is not a part of the public API.  Additionally, it is implied that set_value! must be called only on signals that are pending. Use compute! for a more general way to update signal values.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Computing-Signal-Values","page":"Signals: The Core of Reactivity","title":"Computing Signal Values","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"To compute a signal, use the compute! function, providing a strategy (often a simple function) to calculate the new value based on dependencies. Computing a signal typically clears its pending state.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"note: Note\nBy default, compute! throws an ArgumentError if called on a signal that is not pending (is_pending returns false). You can override this check using the force=true keyword argument.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"\nsignal_1 = Cortex.Signal(1)\nsignal_2 = Cortex.Signal(41)\n\nsignal_to_be_computed = Cortex.Signal()\n\nCortex.add_dependency!(signal_to_be_computed, signal_1)\nCortex.add_dependency!(signal_to_be_computed, signal_2)\n\n@test Cortex.is_pending(signal_to_be_computed) == true # hide\nCortex.is_pending(signal_to_be_computed) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# Define a strategy (a function) to compute the value\ncompute_sum = (signal, deps) -> sum(Cortex.get_value, deps)\n\n# Apply the strategy using compute!\nCortex.compute!(compute_sum, signal_to_be_computed)","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.get_value(signal_to_be_computed) == 1 + 41 # hide\nCortex.get_value(signal_to_be_computed) # 42","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(signal_to_be_computed) == false # hide\nCortex.is_pending(signal_to_be_computed) # false","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"# This would normally throw an error:\n# compute!(compute_sum, signal_to_be_computed)\n\n# But we can force it:\nCortex.compute!(compute_sum, signal_to_be_computed; force=true)\n\n@test Cortex.get_value(signal_to_be_computed) == 42 # hide\nCortex.get_value(signal_to_be_computed) # 42","category":"page"},{"location":"signals/#Custom-Compute-Strategies","page":"Signals: The Core of Reactivity","title":"Custom Compute Strategies","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"You can define custom types and methods to implement more complex computation logic beyond simple functions. This allows strategies to hold their own state or parameters.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"First, define a struct for your strategy:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"struct CustomStrategy\n    multiplier::Int\nend","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Then, implement the compute_value! method for your strategy type:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"function Cortex.compute_value!(strategy::CustomStrategy, signal::Cortex.Signal, dependencies)\n    # Example: Use signal's metadata if available\n    meta = Cortex.get_metadata(signal)\n    base_sum = sum(Cortex.get_value, dependencies)\n    offset = meta isa Dict && haskey(meta, :offset) ? meta[:offset] : 0\n    return strategy.multiplier * base_sum + offset\nend","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Now, you can use this strategy with your signals:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"strategy = CustomStrategy(2)\n\nsignal_with_meta = Cortex.Signal(metadata=Dict(:offset => 10))\n\nCortex.add_dependency!(signal_with_meta, signal_1)\nCortex.add_dependency!(signal_with_meta, signal_2)\n@test Cortex.is_pending(signal_with_meta) # hide\n\nCortex.compute!(strategy, signal_with_meta)\n\n@test Cortex.get_value(signal_with_meta) == 2 * (1 + 41) + 10 # hide\nCortex.get_value(signal_with_meta) # 94","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Cortex.compute!(CustomStrategy(3), signal_with_meta; force=true)\n\n@test Cortex.get_value(signal_with_meta) == 3 * (1 + 41) + 10 # hide\nCortex.get_value(signal_with_meta) # 136","category":"page"},{"location":"signals/#Cortex.compute!-Tuple{Any, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.compute!","text":"compute!(s::Signal, strategy; force::Bool = false, skip_if_no_listeners::Bool = true)\n\nCompute the value of the signal s using the given strategy.  The strategy must implement compute_value! method. If the strategy is a function, it is assumed to be a function that takes the signal and a vector of signal's dependencies as arguments and returns a value. Be sure to call compute! only on signals that are pending.  Calling compute! on a non-pending signal will result in an error.\n\nWhen skip_if_no_listeners is set to true, the function will not compute the signal if it has no listeners. If skip_if_no_listeners is set to false, the function will compute the signal even if it has no listeners. This is useful for signals that are computed on demand with no listeners.\n\nKeyword Arguments:\n\nforce::Bool = false: If true, the signal will be computed even if it is not pending.\nskip_if_no_listeners::Bool = true: If true, the function will not compute the signal if it has no listeners.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}","page":"Signals: The Core of Reactivity","title":"Cortex.compute_value!","text":"compute_value!(strategy, signal, dependencies)\n\nCompute the value of the signal signal using the given strategy. The strategy must implement this method. See also compute!.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Processing-Dependency-Trees-of-Signals-with-process_dependencies!","page":"Signals: The Core of Reactivity","title":"Processing Dependency Trees of Signals with process_dependencies!","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"The process_dependencies! function provides a powerful way to traverse and operate on the dependency graph of a signal. It's particularly useful for scenarios where you need more control over how dependencies are evaluated or when implementing custom update schedulers.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"The function recursively applies a user-defined function f to each dependency. f should return true if it considers the dependency \"processed\" by its own logic, and false otherwise. process_dependencies! propagates this status and can optionally retry processing an intermediate dependency if its own sub-dependencies were processed.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Use Cases:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Implementing custom evaluation orders for signals.\nPerforming actions on dependencies before computing a parent signal.\nDebugging or inspecting the state of a signal's dependency graph.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Conceptual Example:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Imagine you want to traverse the dependency graph of a signal and you want to log which ones were already computed and which ones are not.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"signal1 = Cortex.Signal(1; metadata = :signal1) # computed\nsignal2 = Cortex.Signal(; metadata = :signal2)  # not computed\nsignal3 = Cortex.Signal(3; metadata = :signal3)  # computed\n\nintermediate_signal = Cortex.Signal(metadata = :intermediate_signal)\n\nCortex.add_dependency!(intermediate_signal, signal2)\nCortex.add_dependency!(intermediate_signal, signal3)\n\nderived = Cortex.Signal(metadata = :derived)\n\nCortex.add_dependency!(derived, signal1)\nCortex.add_dependency!(derived, intermediate_signal; intermediate=true)\n\nfunction my_processing_function(dependency_signal::Cortex.Signal)\n    if !Cortex.is_computed(dependency_signal)\n        println(\"The dependency signal: \", Cortex.get_metadata(dependency_signal), \" is not computed\")\n    else \n        println(\"The dependency signal: \", Cortex.get_metadata(dependency_signal), \" is computed. The value is: \", Cortex.get_value(dependency_signal))\n    end\n    # always return false to process all the dependencies\n    return false\nend\n\nCortex.process_dependencies!(my_processing_function, derived)\nnothing #hide","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"This example illustrates how you can inject custom logic into the dependency traversal. The actual computation or state change would happen within my_processing_function. For example, here how can we compute! the signal if it is not computed:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"signal1 = Cortex.Signal(1; metadata = :signal1)\nsignal2 = Cortex.Signal(2; metadata = :signal2)\nsignal3 = Cortex.Signal(3; metadata = :signal3)\n\nintermediate_signal = Cortex.Signal(metadata = :intermediate_signal)\n\nCortex.add_dependency!(intermediate_signal, signal2)\nCortex.add_dependency!(intermediate_signal, signal3)\n\nderived = Cortex.Signal(metadata = :derived)\n\nCortex.add_dependency!(derived, signal1)\nCortex.add_dependency!(derived, intermediate_signal; intermediate=true)\n\nfunction compute_if_not_computed(signal::Cortex.Signal)\n    if Cortex.is_pending(signal)\n        println(\"Computing the signal: \", Cortex.get_metadata(signal))\n        Cortex.compute!((signal, deps) -> sum(Cortex.get_value, deps), signal)\n        return true\n    end\n    return false\nend\n\nCortex.process_dependencies!(compute_if_not_computed, derived; retry = true)\nnothing #hide","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Now, since we processed and computed all the dependencies, the derived signal should be in the pending state:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"@test Cortex.is_pending(derived) == true # hide\nCortex.is_pending(derived) # true","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Which we can also compute using the same function:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"compute_if_not_computed(derived)\n\n@test Cortex.get_value(derived) == 6 # hide\nCortex.get_value(derived) # 6","category":"page"},{"location":"signals/#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}","page":"Signals: The Core of Reactivity","title":"Cortex.process_dependencies!","text":"process_dependencies!(f::F, signal::Signal; retry::Bool = false) where {F}\n\nRecursively processes the dependencies of a signal using a provided function f.\n\nThe function f is applied to each direct dependency of signal. If a dependency is marked as intermediate  and f returns false for it (indicating it was not processed by f according to its own criteria),  process_dependencies! will then be called recursively on that intermediate dependency.\n\nArguments:\n\nf::F: A function (or callable object) that takes a Signal (a dependency) as an argument and returns a Bool.  It should return true if it considered the dependency processed, and false otherwise. The specific logic  for this determination (e.g., checking if a dependency is pending before processing) is up to f.\nsignal::Signal: The signal whose dependencies are to be processed.\n\nKeyword Arguments:\n\nretry::Bool = false: If true, and an intermediate dependency's own sub-dependencies were processed  (i.e., the recursive call to process_dependencies! for the intermediate dependency returned true  because f returned true for at least one sub-dependency), then the function f will be called  again on the intermediate dependency itself. This allows for a second attempt by f to process the  intermediate dependency after its own prerequisites might have been met by processing its sub-dependencies.\n\nReturns:\n\nBool: true if the function f returned true for at least one dependency encountered (either directly  or recursively through an intermediate one). Returns false if f returned false for all dependencies  it was applied to.\n\nBehavior Details:\n\nFor each dependency of signal:\nf(dependency) is called.\nIf f(dependency) returns true, this dependency is considered processed by f.\nIf f(dependency) returns false AND the dependency is marked as intermediate:  a. process_dependencies!(f, dependency; retry=retry) is called recursively.  b. If this recursive call returns true (meaning f processed at least one sub-dependency of the      intermediate one) AND retry is true, then f(dependency) is called again.\nThe function tracks whether f returned true for any dependency it was applied to, at any level of  recursion (for intermediate dependencies) or direct application, and returns this aggregated result.\n\n\n\n\n\n","category":"method"},{"location":"signals/#Internal-Mechanics-(For-Developers)","page":"Signals: The Core of Reactivity","title":"Internal Mechanics (For Developers)","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"warning: Advanced Topic\nThe details in this section are primarily for developers working on or extending Cortex.jl's core reactivity. Regular users do not typically need to interact with these internal components directly.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"The efficient tracking of dependency states (intermediate, weak, computed, and fresh) is managed internally by a structure associated with each signal, SignalDependenciesProps.","category":"page"},{"location":"signals/#SignalDependenciesProps:-Packed-Dependency-Information","page":"Signals: The Core of Reactivity","title":"SignalDependenciesProps: Packed Dependency Information","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"To minimize overhead, the properties for each dependency are bit-packed into 4-bit \"nibbles\" within UInt64 chunks. This allows a single UInt64 to hold status information for 16 dependencies. The bits are assigned as follows (from LSB to MSB):","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"Bit 1 (0x1): IsIntermediate: True if the dependency is an intermediate one for processing logic (see process_dependencies!).\nBit 2 (0x2): IsWeak: True if the dependency is weak.\nBit 3 (0x4): IsComputed: True if the dependency itself holds a computed value.\nBit 4 (0x8): IsFresh: True if the dependency has provided a new value that has not yet been consumed by the current signal's computation.","category":"page"},{"location":"signals/#Determining-Pending-State","page":"Signals: The Core of Reactivity","title":"Determining Pending State","text":"","category":"section"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"The is_pending(signal) function relies on an internal check (currently is_meeting_pending_criteria) that operates on these packed properties. A signal is considered to meet the criteria to become pending if, for every one of its dependencies:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"(IsComputed AND (IsWeak OR IsFresh))","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"This means:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"A weak dependency must simply be IsComputed.\nA strong (non-weak) dependency must be IsComputed AND IsFresh.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"When set_value! is called on a signal:","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"The IsFresh flags for all its own dependencies are cleared (as their values have now been \"used\").\nFor each of its listeners, the original signal (which just got a new value) is marked as IsComputed and IsFresh in that listener's dependency properties. This, in turn, can cause the listener to become pending.","category":"page"},{"location":"signals/","page":"Signals: The Core of Reactivity","title":"Signals: The Core of Reactivity","text":"This bit-packed approach allows for efficient batch updates and checks across many dependencies.","category":"page"},{"location":"#Cortex","page":"Home","title":"Cortex","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cortex. Cortex is a simple, efficient and modular framework for running message passing algorithms on graphs, with a focus on message-passing based Bayesian inference. This is a successor to the ReactiveMP.jl package.","category":"page"},{"location":"#Where-To-Go-Next?","page":"Home","title":"Where To Go Next?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Signals - Read about core reactive programming concepts with the Signal type.\nInference - Learn how Cortex uses the InferenceEngine to perform inference on a probabilistic model.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"inference/#inference","page":"Probabilistic Inference with Cortex","title":"Inference Engine","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"The InferenceEngine is the central component in Cortex.jl for performing probabilistic inference. It acts as an abstraction layer over different model backends, providing a consistent API for interacting with models and running inference algorithms.","category":"page"},{"location":"inference/#Concept","page":"Probabilistic Inference with Cortex","title":"Concept","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"The primary role of the InferenceEngine is to:","category":"page"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"Manage a Model Backend: It holds an instance of a specific model structure (e.g., a BipartiteFactorGraph).\nProvide a Standardized API: It offers a set of functions to access and manipulate model components like variables, factors, and their connections, regardless of the underlying backend's specific implementation.\nOrchestrate Inference: It uses the reactive Signal system to manage the flow of messages and marginals. When data or priors change, the engine helps identify which parts of the model need updates.\nExecute Computations: It facilitates the application of user-defined computation functions (rules for how messages and marginals are calculated) to update the model's state using the update_marginals! function.","category":"page"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"Upon creation, the InferenceEngine can automatically prepare the metadata of the signals within the model (marginals, messages to variables, messages to factors) by calling prepare_signals_metadata!. This step is crucial as it assigns specific types and metadata (like variable or factor IDs) to signals, which are often used by the computation functions during inference.","category":"page"},{"location":"inference/#Core-API","page":"Probabilistic Inference with Cortex","title":"Core API","text":"","category":"section"},{"location":"inference/#Cortex.InferenceEngine","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceEngine","text":"InferenceEngine{M}\n\nCore structure for managing and executing inference tasks on a given model backend.\n\nFields\n\nmodel_backend::M: The underlying model backend (e.g., a BipartiteFactorGraph) on which inference is performed. It must conform to the Cortex.jl backend interface.\n\nConstructor\n\nInferenceEngine(; model_backend::M, prepare_signals_metadata::Bool = true) where {M}\n\nmodel_backend: An instance of a supported model backend.\nprepare_signals_metadata::Bool (default: true): If true, calls prepare_signals_metadata! upon construction to initialize signal types and metadata. This is typically required for inference algorithms.\n\nOverview\n\nThe InferenceEngine orchestrates message passing and marginal computation within a probabilistic model using the Signal reactivity system. It provides a standardized API for:\n\nAccessing model components (variables, factors, connections).\nRetrieving reactive signals for marginals and messages.\nManaging inference execution via update_marginals! and request_inference_for.\n\nThe engine interacts with the model_backend through a defined interface (e.g., Cortex.get_variable_data(backend, id)), implemented by backend-specific extensions.\n\nSee Also\n\nget_model_backend\nprepare_signals_metadata!\nis_backend_supported\nupdate_marginals!\nrequest_inference_for\nSignal\n\n\n\n\n\n","category":"type"},{"location":"inference/#Engine-and-Backend-Management","page":"Probabilistic Inference with Cortex","title":"Engine and Backend Management","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"These functions allow you to interact with the engine itself and its underlying model backend.","category":"page"},{"location":"inference/#Cortex.get_model_backend","page":"Probabilistic Inference with Cortex","title":"Cortex.get_model_backend","text":"get_model_backend(engine::InferenceEngine)\n\nRetrieves the underlying model backend from the InferenceEngine.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\n\nReturns\n\nThe model backend object stored within the engine.\n\nSee Also\n\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.is_backend_supported","page":"Probabilistic Inference with Cortex","title":"Cortex.is_backend_supported","text":"is_backend_supported(backend::Any) -> Union{SupportedModelBackend, UnsupportedModelBackend}\n\nChecks if a given backend is supported by the InferenceEngine.\n\nThis function should be extended by specific backend implementations.\n\nArguments\n\nbackend::Any: The model backend instance to check.\n\nReturns\n\nSupportedModelBackend() if the backend is supported.\nUnsupportedModelBackend() otherwise.\n\nSee Also\n\nSupportedModelBackend\nUnsupportedModelBackend\nthrow_if_backend_unsupported\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.SupportedModelBackend","page":"Probabilistic Inference with Cortex","title":"Cortex.SupportedModelBackend","text":"A trait object indicating a supported model backend.\n\n\n\n\n\n","category":"type"},{"location":"inference/#Cortex.UnsupportedModelBackend","page":"Probabilistic Inference with Cortex","title":"Cortex.UnsupportedModelBackend","text":"A trait object indicating an unsupported model backend.\n\n\n\n\n\n","category":"type"},{"location":"inference/#Accessing-Model-Components","page":"Probabilistic Inference with Cortex","title":"Accessing Model Components","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"The engine provides a suite of functions to retrieve data and reactive signals associated with variables, factors, and their connections.","category":"page"},{"location":"inference/#Variables","page":"Probabilistic Inference with Cortex","title":"Variables","text":"","category":"section"},{"location":"inference/#Cortex.get_variable_data","page":"Probabilistic Inference with Cortex","title":"Cortex.get_variable_data","text":"get_variable_data(engine::InferenceEngine, variable_id)\n\nRetrieves the data structure representing a specific variable from the engine's model backend.\n\nThis function dispatches to the get_variable_data(backend, variable_id) method of the specific model backend. The returned object must implement get_marginal(variable_data_object) -> Cortex.Signal.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable to retrieve.\n\nReturns\n\nA backend-specific data structure for the variable.\n\nSee Also\n\nget_marginal\nget_variable_ids\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.get_variable_ids","page":"Probabilistic Inference with Cortex","title":"Cortex.get_variable_ids","text":"get_variable_ids(engine::InferenceEngine)\n\nRetrieves an iterator over all variable identifiers in the engine's model backend.\n\nThis function dispatches to the get_variable_ids(backend) method of the specific model backend.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\n\nReturns\n\nAn iterator of variable identifiers.\n\nSee Also\n\nget_variable_data\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.get_marginal-Tuple{Cortex.InferenceEngine, Any}","page":"Probabilistic Inference with Cortex","title":"Cortex.get_marginal","text":"get_marginal(engine::InferenceEngine, variable_id) -> Cortex.Signal\n\nRetrieves the marginal Signal for a given variable_id from the InferenceEngine.\n\nThis is a convenience function calling get_marginal(get_variable_data(engine, variable_id)).\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable.\n\nReturns\n\nCortex.Signal: The reactive signal representing the variable's marginal.\n\nSee Also\n\nget_variable_data\nget_marginal(::Any)\nInferenceEngine\n\n\n\n\n\n","category":"method"},{"location":"inference/#Factors","page":"Probabilistic Inference with Cortex","title":"Factors","text":"","category":"section"},{"location":"inference/#Cortex.get_factor_data","page":"Probabilistic Inference with Cortex","title":"Cortex.get_factor_data","text":"get_factor_data(engine::InferenceEngine, factor_id)\n\nRetrieves the data structure representing a specific factor from the engine's model backend.\n\nThis function dispatches to the get_factor_data(backend, factor_id) method of the specific model backend.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nfactor_id: The identifier of the factor to retrieve.\n\nReturns\n\nA backend-specific data structure for the factor.\n\nSee Also\n\nget_factor_ids\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.get_factor_ids","page":"Probabilistic Inference with Cortex","title":"Cortex.get_factor_ids","text":"get_factor_ids(engine::InferenceEngine)\n\nRetrieves an iterator over all factor identifiers in the engine's model backend.\n\nThis function dispatches to the get_factor_ids(backend) method of the specific model backend.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\n\nReturns\n\nAn iterator of factor identifiers.\n\nSee Also\n\nget_factor_data\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Connections-and-Messages","page":"Probabilistic Inference with Cortex","title":"Connections and Messages","text":"","category":"section"},{"location":"inference/#Cortex.get_connection","page":"Probabilistic Inference with Cortex","title":"Cortex.get_connection","text":"get_connection(engine::InferenceEngine, variable_id, factor_id)\n\nRetrieves the data structure representing the connection between a specified variable_id and factor_id.\n\nThis function dispatches to the get_connection(backend, variable_id, factor_id) method of the specific model backend. The returned object must implement:\n\nget_connection_label(connection_object) -> Symbol\nget_connection_index(connection_object) -> Int\nget_message_to_variable(connection_object) -> Cortex.Signal\nget_message_to_factor(connection_object) -> Cortex.Signal\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable in the connection.\nfactor_id: The identifier of the factor in the connection.\n\nReturns\n\nA backend-specific data structure for the connection.\n\nSee Also\n\nget_connection_label\nget_connection_index\nget_message_to_variable\nget_message_to_factor\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.get_connection_label-Tuple{Cortex.InferenceEngine, Any, Any}","page":"Probabilistic Inference with Cortex","title":"Cortex.get_connection_label","text":"get_connection_label(engine::InferenceEngine, variable_id, factor_id) -> Symbol\n\nRetrieves the label of the connection between variable_id and factor_id.\n\nThis is a convenience function calling get_connection_label(get_connection(engine, variable_id, factor_id)).\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable.\nfactor_id: The identifier of the factor.\n\nReturns\n\nSymbol: The label of the connection.\n\nSee Also\n\nget_connection\nget_connection_label(::Any)\nInferenceEngine\n\n\n\n\n\n","category":"method"},{"location":"inference/#Cortex.get_connection_index-Tuple{Cortex.InferenceEngine, Any, Any}","page":"Probabilistic Inference with Cortex","title":"Cortex.get_connection_index","text":"get_connection_index(engine::InferenceEngine, variable_id, factor_id) -> Int\n\nRetrieves the index of the connection between variable_id and factor_id.\n\nThis is a convenience function calling get_connection_index(get_connection(engine, variable_id, factor_id)).\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable.\nfactor_id: The identifier of the factor.\n\nReturns\n\nInt: The index of the connection.\n\nSee Also\n\nget_connection\nget_connection_index(::Any)\nInferenceEngine\n\n\n\n\n\n","category":"method"},{"location":"inference/#Cortex.get_message_to_variable-Tuple{Cortex.InferenceEngine, Any, Any}","page":"Probabilistic Inference with Cortex","title":"Cortex.get_message_to_variable","text":"get_message_to_variable(engine::InferenceEngine, variable_id, factor_id) -> Cortex.Signal\n\nRetrieves the message Signal from factor_id to variable_id.\n\nThis is a convenience function calling get_message_to_variable(get_connection(engine, variable_id, factor_id)).\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the target variable.\nfactor_id: The identifier of the source factor.\n\nReturns\n\nCortex.Signal: The reactive signal for the message.\n\nSee Also\n\nget_connection\nget_message_to_variable(::Any)\nInferenceEngine\n\n\n\n\n\n","category":"method"},{"location":"inference/#Cortex.get_message_to_factor-Tuple{Cortex.InferenceEngine, Any, Any}","page":"Probabilistic Inference with Cortex","title":"Cortex.get_message_to_factor","text":"get_message_to_factor(engine::InferenceEngine, variable_id, factor_id) -> Cortex.Signal\n\nRetrieves the message Signal from variable_id to factor_id.\n\nThis is a convenience function calling get_message_to_factor(get_connection(engine, variable_id, factor_id)).\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the source variable.\nfactor_id: The identifier of the target factor.\n\nReturns\n\nCortex.Signal: The reactive signal for the message.\n\nSee Also\n\nget_connection\nget_message_to_factor(::Any)\nInferenceEngine\n\n\n\n\n\n","category":"method"},{"location":"inference/#Cortex.get_connected_variable_ids","page":"Probabilistic Inference with Cortex","title":"Cortex.get_connected_variable_ids","text":"get_connected_variable_ids(engine::InferenceEngine, factor_id)\n\nRetrieves an iterator over the identifiers of variables connected to a given factor_id.\n\nThis function dispatches to the get_connected_variable_ids(backend, factor_id) method of the specific model backend.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nfactor_id: The identifier of the factor.\n\nReturns\n\nAn iterator of connected variable identifiers.\n\nSee Also\n\nget_connected_factor_ids\nget_connection\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Cortex.get_connected_factor_ids","page":"Probabilistic Inference with Cortex","title":"Cortex.get_connected_factor_ids","text":"get_connected_factor_ids(engine::InferenceEngine, variable_id)\n\nRetrieves an iterator over the identifiers of factors connected to a given variable_id.\n\nThis function dispatches to the get_connected_factor_ids(backend, variable_id) method of the specific model backend.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id: The identifier of the variable.\n\nReturns\n\nAn iterator of connected factor identifiers.\n\nSee Also\n\nget_connected_variable_ids\nget_connection\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/#Signal-Metadata-and-Types","page":"Probabilistic Inference with Cortex","title":"Signal Metadata and Types","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"Understanding and managing signal metadata is key for many inference algorithms.","category":"page"},{"location":"inference/#Cortex.InferenceSignalTypes","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes","text":"InferenceSignalTypes\n\nModule defining constants for different types of signals used within the inference engine. These types help in dispatching computation rules and managing signal metadata.\n\nConstants\n\nMessageToVariable: Signal representing a message from a factor to a variable.\nMessageToFactor: Signal representing a message from a variable to a factor.\nProductOfMessages: Signal representing an intermediate product of messages, often a dependency for an IndividualMarginal.\nIndividualMarginal: Signal representing the marginal distribution of a single variable.\nJointMarginal: Signal representing the joint marginal distribution of a set of variables.\n\nSee Also\n\nprepare_signals_metadata!\nSignal\n\n\n\n\n\n","category":"module"},{"location":"inference/#Cortex.InferenceSignalTypes.MessageToVariable","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes.MessageToVariable","text":"Type constant for a Signal representing a message from a factor to a variable.\n\n\n\n\n\n","category":"constant"},{"location":"inference/#Cortex.InferenceSignalTypes.MessageToFactor","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes.MessageToFactor","text":"Type constant for a Signal representing a message from a variable to a factor.\n\n\n\n\n\n","category":"constant"},{"location":"inference/#Cortex.InferenceSignalTypes.ProductOfMessages","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes.ProductOfMessages","text":"Type constant for a Signal representing an intermediate product of messages.\n\n\n\n\n\n","category":"constant"},{"location":"inference/#Cortex.InferenceSignalTypes.IndividualMarginal","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes.IndividualMarginal","text":"Type constant for a Signal representing the marginal distribution of a single variable.\n\n\n\n\n\n","category":"constant"},{"location":"inference/#Cortex.InferenceSignalTypes.JointMarginal","page":"Probabilistic Inference with Cortex","title":"Cortex.InferenceSignalTypes.JointMarginal","text":"Type constant for a Signal representing the joint marginal distribution of a set of variables.\n\n\n\n\n\n","category":"constant"},{"location":"inference/#Cortex.prepare_signals_metadata!","page":"Probabilistic Inference with Cortex","title":"Cortex.prepare_signals_metadata!","text":"prepare_signals_metadata!(engine::InferenceEngine)\n\nInitializes the type and metadata fields for relevant signals within the InferenceEngine.\n\nThis function iterates through variables and factors in the model backend, setting:\n\nMarginals: type to IndividualMarginal and metadata to (variable_id,).\nMessages to Factors: type to MessageToFactor and metadata to (variable_id, factor_id).\nMessages to Variables: type to MessageToVariable and metadata to (variable_id, factor_id).\n\nThis setup is typically done once upon engine creation and is crucial for dispatching appropriate computation rules during inference.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance whose signals are to be prepared.\n\nSee Also\n\nInferenceEngine\nInferenceSignalTypes\n\n\n\n\n\n","category":"function"},{"location":"inference/#Running-Inference","page":"Probabilistic Inference with Cortex","title":"Running Inference","text":"","category":"section"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"These functions are used to initiate and execute the inference process.","category":"page"},{"location":"inference/#Cortex.request_inference_for","page":"Probabilistic Inference with Cortex","title":"Cortex.request_inference_for","text":"request_inference_for(engine::InferenceEngine, variable_id_or_ids)\n\nCreates an InferenceRequest to compute the marginals for the specified variable_id_or_ids.\n\nThis function prepares the necessary signals by marking their dependencies as potentially pending. It supports requesting inference for a single variable ID or a collection (Tuple or AbstractVector) of variable IDs.\n\nArguments\n\nengine::InferenceEngine: The inference engine instance.\nvariable_id_or_ids: A single variable identifier or a collection of variable identifiers.\n\nReturns\n\nInferenceRequest: An internal structure representing the inference request.\n\nSee Also\n\nupdate_marginals!\nInferenceEngine\n\n\n\n\n\n","category":"function"},{"location":"inference/","page":"Probabilistic Inference with Cortex","title":"Probabilistic Inference with Cortex","text":"","category":"page"}]
}
