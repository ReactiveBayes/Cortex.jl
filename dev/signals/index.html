<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Signals: The Core of Reactivity · Cortex.jl</title><meta name="title" content="Signals: The Core of Reactivity · Cortex.jl"/><meta property="og:title" content="Signals: The Core of Reactivity · Cortex.jl"/><meta property="twitter:title" content="Signals: The Core of Reactivity · Cortex.jl"/><meta name="description" content="Documentation for Cortex.jl."/><meta property="og:description" content="Documentation for Cortex.jl."/><meta property="twitter:description" content="Documentation for Cortex.jl."/><meta property="og:url" content="https://ReactiveBayes.github.io/Cortex.jl/signals/"/><meta property="twitter:url" content="https://ReactiveBayes.github.io/Cortex.jl/signals/"/><link rel="canonical" href="https://ReactiveBayes.github.io/Cortex.jl/signals/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Cortex.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Signals: The Core of Reactivity</a><ul class="internal"><li><a class="tocitem" href="#Concept"><span>Concept</span></a></li><li><a class="tocitem" href="#Key-Features"><span>Key Features</span></a></li><li><a class="tocitem" href="#Core-Operations"><span>Core Operations</span></a></li><li><a class="tocitem" href="#Internal-Mechanics-(For-Developers)"><span>Internal Mechanics (For Developers)</span></a></li></ul></li><li><a class="tocitem" href="../inference/">Probabilistic Inference with Cortex</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Signals: The Core of Reactivity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Signals: The Core of Reactivity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/Cortex.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ReactiveBayes/Cortex.jl/blob/main/docs/src/signals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="signals"><a class="docs-heading-anchor" href="#signals">Signals: The Core of Reactivity</a><a id="signals-1"></a><a class="docs-heading-anchor-permalink" href="#signals" title="Permalink"></a></h1><p>At the heart of Cortex.jl&#39;s reactivity system lies the <a href="#Cortex.Signal"><code>Signal</code></a>.</p><h2 id="Concept"><a class="docs-heading-anchor" href="#Concept">Concept</a><a id="Concept-1"></a><a class="docs-heading-anchor-permalink" href="#Concept" title="Permalink"></a></h2><p>Think of a <a href="#Cortex.Signal"><code>Signal</code></a> as a container for a value that can change over time. The key idea is that other parts of your system can <em>depend</em> on a signal. When the signal&#39;s value changes, anything that depends on it (its <em>listeners</em>) is notified, allowing the system to react on changes and recompute values.</p><p>Imagine a spreadsheet cell. When you change the value in one cell (like <code>A1</code>), other cells that use <code>A1</code> in their formulas (like <code>B1 = A1 * 2</code>) automatically update. A <a href="#Cortex.Signal"><code>Signal</code></a> is like that cell – it holds a value, and changes can trigger updates elsewhere.</p><p>More technically, <a href="#Cortex.Signal"><code>Signal</code></a>s form a directed graph (potentially cyclic). Each <a href="#Cortex.Signal"><code>Signal</code></a> node stores a value, an optional <code>type</code> identifier (<code>UInt8</code>), optional <code>metadata</code>, and maintains lists of its dependencies and listeners. When a signal is updated via <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a>, it propagates a notification to its direct listeners, potentially marking them as &#39;pending&#39;. This &#39;pending&#39; state indicates that the signal&#39;s value might be stale and needs recomputation. The actual recomputation logic is defined externally via the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function. A signal may become &#39;pending&#39; if all its dependencies meet the criteria: weak dependencies are computed, and strong dependencies are computed and <strong>fresh</strong> (i.e., have new, unused values). This also means that a signal never recomputes its own value, as it must be done externally.</p><h2 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h2><ul><li><strong>Value Storage:</strong> Holds the current value.</li><li><strong>Type Identifier:</strong> Stores an optional <code>UInt8</code> type (<a href="#Cortex.get_type-Tuple{Cortex.Signal}"><code>get_type</code></a>), defaulting to <code>0x00</code>. This might be particularly useful for choosing different computation strategies for different types of signals within the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function.</li><li><strong>Optional Metadata:</strong> Can store arbitrary metadata (<a href="#Cortex.get_metadata-Tuple{Cortex.Signal}"><code>get_metadata</code></a>), defaulting to <code>UndefMetadata()</code>.</li><li><strong>Dependency Tracking:</strong> Knows which other signals it depends on (<code>dependencies</code>) and which signals depend on it (see  <a href="#Cortex.get_listeners-Tuple{Cortex.Signal}"><code>get_listeners</code></a>).</li><li><strong>Notification:</strong> When updated via <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a>, it notifies its active listeners.</li><li><strong>Pending State:</strong> Can be marked as <a href="#Cortex.is_pending-Tuple{Cortex.Signal}"><code>is_pending</code></a> if its dependencies have updated appropriately, signaling a need for recomputation via <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a>.</li><li><strong>External Computation:</strong> Relies on the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function and a provided strategy to update its value based on dependencies.</li><li><strong>Weak Dependencies:</strong> Supports &#39;weak&#39; dependencies, which influence the pending state based only on whether they are computed (<a href="#Cortex.is_computed-Tuple{Cortex.Signal}"><code>is_computed</code></a>), not their &#39;fresh&#39; status in the same way as strong dependencies. See <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a> for more details.</li><li><strong>Controlled Listening:</strong> Allows dependencies to be added without automatically listening to their updates (<code>listen=false</code> in <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a>).</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.Signal" href="#Cortex.Signal"><code>Cortex.Signal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Signal()
Signal(value; type::UInt8 = 0x00, metadata::Any = UndefMetadata())</code></pre><p>A reactive signal that holds a value and tracks dependencies as well as notifies listeners when the value changes. If created without an initial value, the signal is initialized with <a href="#Cortex.UndefValue"><code>UndefValue()</code></a>. The <code>metadata</code> field can be used to store arbitrary metadata about the signal. Default value is <a href="#Cortex.UndefMetadata"><code>UndefMetadata()</code></a>.</p><p>A signal is said to be &#39;pending&#39; if it is ready for potential recomputation (due to updated dependencies). However, a signal is not recomputed immediately when it becomes pending. Moreover, a Signal does not know  how to recompute itself. The recomputation logic is defined separately with the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function.</p><p>Signals form a directed graph where edges represent dependencies. When a signal&#39;s value is updated via <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a>, it notifies its active listeners.</p><p>A signal may become &#39;pending&#39; if all its dependencies meet the following criteria:</p><ul><li>all its weak dependencies have computed values, AND</li><li>all its strong dependencies have computed values and are older than the listener.</li></ul><p>A signal can depend on another signal without listening to it, see <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a> for more details.</p><p>The <code>type</code> field is an optional <code>UInt8</code> type identifier.  It might be useful to choose different computation strategies for different types of signals within the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function.</p><p>See also: <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a>, <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a>, <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a>, <a href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>process_dependencies!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L53-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.UndefValue" href="#Cortex.UndefValue"><code>Cortex.UndefValue</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UndefValue</code></pre><p>A singleton type used to represent an undefined or uninitialized state within a <a href="#Cortex.Signal"><code>Signal</code></a>. This indicates that the signal has not yet been computed or has been invalidated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.UndefMetadata" href="#Cortex.UndefMetadata"><code>Cortex.UndefMetadata</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UndefMetadata</code></pre><p>A singleton type used to represent an undefined or uninitialized state within a <a href="#Cortex.Signal"><code>Signal</code></a>. This indicates that the signal has no metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L9-L14">source</a></section></article><h2 id="Core-Operations"><a class="docs-heading-anchor" href="#Core-Operations">Core Operations</a><a id="Core-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Operations" title="Permalink"></a></h2><p>Here are some basic examples demonstrating how to use signals.</p><h3 id="Creating-Signals-and-Checking-Properties"><a class="docs-heading-anchor" href="#Creating-Signals-and-Checking-Properties">Creating Signals and Checking Properties</a><a id="Creating-Signals-and-Checking-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Signals-and-Checking-Properties" title="Permalink"></a></h3><p>Signals can be created with or without an initial value. You can optionally specify a <code>type</code> identifier and <code>metadata</code>.</p><pre><code class="language-julia hljs">import Cortex

# Create signals
s1 = Cortex.Signal(10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Signal(value=10, pending=false)</code></pre><pre><code class="language-julia hljs"> # Initial value, computed=true
s2 = Cortex.Signal(5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Signal(value=5, pending=false)</code></pre><pre><code class="language-julia hljs"># No initial value, computed=false
s3 = Cortex.Signal()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Signal(value=#undef, pending=false)</code></pre><pre><code class="language-julia hljs"># Signal with type and metadata
s4 = Cortex.Signal(true; type=0x01, metadata=Dict(:info =&gt; &quot;flag&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Signal(value=true, pending=false, type=0x01, metadata=Dict(:info =&gt; &quot;flag&quot;))</code></pre><h4 id="Checking-Properties-of-Signals"><a class="docs-heading-anchor" href="#Checking-Properties-of-Signals">Checking Properties of Signals</a><a id="Checking-Properties-of-Signals-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-Properties-of-Signals" title="Permalink"></a></h4><pre><code class="language-julia hljs">Cortex.get_value(s1)   # 10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><pre><code class="language-julia hljs">Cortex.get_value(s3)   # Cortex.UndefValue()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cortex.UndefValue()</code></pre><pre><code class="language-julia hljs">Cortex.is_computed(s1) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">Cortex.is_computed(s3) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs">Cortex.get_type(s1) # 0x00 (default)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0x00</code></pre><pre><code class="language-julia hljs">Cortex.get_type(s4) # 0x01</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0x01</code></pre><pre><code class="language-julia hljs">Cortex.get_metadata(s1) # UndefMetadata() (default)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Cortex.UndefMetadata()</code></pre><pre><code class="language-julia hljs">Cortex.get_metadata(s4) # Dict{Symbol, String}(:info =&gt; &quot;flag&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, String} with 1 entry:
  :info =&gt; &quot;flag&quot;</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.get_value-Tuple{Cortex.Signal}" href="#Cortex.get_value-Tuple{Cortex.Signal}"><code>Cortex.get_value</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_value(s::Signal)</code></pre><p>Get the current value of the signal <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.get_type-Tuple{Cortex.Signal}" href="#Cortex.get_type-Tuple{Cortex.Signal}"><code>Cortex.get_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_type(s::Signal) -&gt; UInt8</code></pre><p>Get the type identifier (UInt8) of the signal <code>s</code>. Defaults to <code>0x00</code> if not specified during construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.get_metadata-Tuple{Cortex.Signal}" href="#Cortex.get_metadata-Tuple{Cortex.Signal}"><code>Cortex.get_metadata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_metadata(s::Signal)</code></pre><p>Get the metadata associated with the signal <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.is_computed-Tuple{Cortex.Signal}" href="#Cortex.is_computed-Tuple{Cortex.Signal}"><code>Cortex.is_computed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_computed(s::Signal) -&gt; Bool</code></pre><p>Check if the signal <code>s</code> has been computed (i.e., its value is not equal to <a href="#Cortex.UndefValue"><code>UndefValue()</code></a>). See also: <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.is_pending-Tuple{Cortex.Signal}" href="#Cortex.is_pending-Tuple{Cortex.Signal}"><code>Cortex.is_pending</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_pending(s::Signal) -&gt; Bool</code></pre><p>Check if the signal <code>s</code> is marked as pending. This usually indicates that the signal&#39;s value is stale and needs recomputation. See also: <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a>, <a href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>process_dependencies!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L121-L126">source</a></section></article><h3 id="Adding-Dependencies"><a class="docs-heading-anchor" href="#Adding-Dependencies">Adding Dependencies</a><a id="Adding-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Dependencies" title="Permalink"></a></h3><p>Signals can depend on other signals. Use <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a> to create these links. This populates the <code>dependencies</code> list of the dependent signal and the <code>listeners</code> list of the dependency.</p><pre><code class="language-julia hljs">source_1 = Cortex.Signal(1)
source_2 = Cortex.Signal(2)

derived = Cortex.Signal() # A signal that will depend on s1 and s2

Cortex.add_dependency!(derived, source_1)
Cortex.add_dependency!(derived, source_2)</code></pre><pre><code class="language-julia hljs">length(Cortex.get_dependencies(derived)) # 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><pre><code class="language-julia hljs">length(Cortex.get_listeners(source_1))           # 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><pre><code class="language-julia hljs">length(Cortex.get_listeners(source_2))           # 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><h3 id="Types-of-Dependencies"><a class="docs-heading-anchor" href="#Types-of-Dependencies">Types of Dependencies</a><a id="Types-of-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Dependencies" title="Permalink"></a></h3><p>Cortex supports different types of dependencies through options in <a href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>add_dependency!</code></a>:</p><h4 id="Strong-vs.-Weak-Dependencies"><a class="docs-heading-anchor" href="#Strong-vs.-Weak-Dependencies">Strong vs. Weak Dependencies</a><a id="Strong-vs.-Weak-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Strong-vs.-Weak-Dependencies" title="Permalink"></a></h4><p>By default, dependencies are &quot;strong,&quot; meaning they must be both computed and fresh (recently updated) for a signal to become pending. With <code>weak=true</code>, a dependency only needs to be computed (not necessarily fresh) to contribute to the pending state.</p><pre><code class="language-julia hljs">weak_dependency = Cortex.Signal(1)
strong_dependency = Cortex.Signal(2)

derived = Cortex.Signal(3)

Cortex.add_dependency!(derived, weak_dependency; weak=true)
Cortex.add_dependency!(derived, strong_dependency)

Cortex.is_pending(derived) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs">Cortex.set_value!(strong_dependency, 10)

Cortex.is_pending(derived) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Here, even though <code>weak_dependency</code> has not been updated, <code>derived</code> is still in the pending state because it only needs <code>strong_dependency</code> to be updated and <code>weak_dependency</code> only needs to be computed once (or set via constructor).</p><h4 id="Listening-vs.-Non-listening-Dependencies"><a class="docs-heading-anchor" href="#Listening-vs.-Non-listening-Dependencies">Listening vs. Non-listening Dependencies</a><a id="Listening-vs.-Non-listening-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Listening-vs.-Non-listening-Dependencies" title="Permalink"></a></h4><p>With <code>listen=true</code> (default), a signal is notified when its dependency changes. Setting <code>listen=false</code> creates a dependency relationship without automatic notifications, useful when you want to manually control when a signal responds to changes.</p><pre><code class="language-julia hljs">s_source = Cortex.Signal()
s_non_listener = Cortex.Signal()

Cortex.add_dependency!(s_non_listener, s_source; listen=false)</code></pre><pre><code class="language-julia hljs">Cortex.is_pending(s_non_listener) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs"># Update s_source. s_non_listener is NOT notified.
Cortex.set_value!(s_source, 6)</code></pre><pre><code class="language-julia hljs">Cortex.is_pending(s_non_listener) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><h4 id="Intermediate-Dependencies"><a class="docs-heading-anchor" href="#Intermediate-Dependencies">Intermediate Dependencies</a><a id="Intermediate-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Intermediate-Dependencies" title="Permalink"></a></h4><p>Setting <code>intermediate=true</code> marks a dependency as intermediate, which affects how <a href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>process_dependencies!</code></a> traverses the dependency graph. This is useful for complex dependency trees where some nodes serve as connectors between different parts of the graph.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}" href="#Cortex.add_dependency!-Tuple{Cortex.Signal, Cortex.Signal}"><code>Cortex.add_dependency!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_dependency!(signal::Signal, dependency::Signal; weak::Bool = false, listen::Bool = true, intermediate::Bool = false)</code></pre><p>Add <code>dependency</code> to the list of dependencies for signal <code>signal</code>. Also adds <code>signal</code> to the list of listeners for <code>dependency</code>.</p><p>Arguments:</p><ul><li><code>signal::Signal</code>: The signal to add a dependency to.</li><li><code>dependency::Signal</code>: The signal to be added as a dependency.</li></ul><p>Keyword Arguments:</p><ul><li><code>intermediate::Bool = false</code>: If <code>true</code>, marks the dependency as intermediate. Intermediate dependencies</li></ul><p>have an effect on the <code>process_dependencies!</code> function. See the documentation of <a href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>process_dependencies!</code></a> for more details. By default, the added dependency is not intermediate.</p><ul><li><code>weak::Bool = false</code>: If <code>true</code>, marks the dependency as weak. Weak dependencies only require <code>is_computed</code> to be true (not necessarily older) for the dependent signal <code>signal</code> to potentially become pending.</li><li><code>listen::Bool = true</code>: If <code>true</code>, <code>signal</code> will be notified when <code>dependency</code> is updated. If <code>false</code>, <code>dependency</code> is added, but <code>signal</code> will not automatically be notified of updates to <code>dependency</code>.</li><li><code>check_computed::Bool = true</code>: If <code>true</code>, the function will check if <code>dependency</code> is already computed.</li></ul><p>If so, it will notify <code>signal</code> immediately. Note that if <code>listen</code> is set to false,  further updates to <code>dependency</code> will not trigger notifications to <code>signal</code>.</p><p>The same dependency should not be added multiple times. Doing so will result in wrong notification behaviour and likely will lead to incorrect results. Note that this function does nothing if <code>signal === dependency</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L232-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.get_dependencies-Tuple{Cortex.Signal}" href="#Cortex.get_dependencies-Tuple{Cortex.Signal}"><code>Cortex.get_dependencies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_dependencies(s::Signal) -&gt; Vector{Signal}</code></pre><p>Get the list of signals that the signal <code>s</code> depends on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.get_listeners-Tuple{Cortex.Signal}" href="#Cortex.get_listeners-Tuple{Cortex.Signal}"><code>Cortex.get_listeners</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_listeners(s::Signal) -&gt; Vector{Signal}</code></pre><p>Get the list of signals that listen to the signal <code>s</code> (i.e., signals that depend on <code>s</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L189-L193">source</a></section></article><h3 id="Pending-State"><a class="docs-heading-anchor" href="#Pending-State">Pending State</a><a id="Pending-State-1"></a><a class="docs-heading-anchor-permalink" href="#Pending-State" title="Permalink"></a></h3><p>A signal becomes pending (<a href="#Cortex.is_pending-Tuple{Cortex.Signal}"><code>is_pending</code></a> returns <code>true</code>) when its dependencies are updated in a way that satisfies the pending criteria (all weak dependencies are computed, and all strong dependencies are <strong>fresh</strong> and computed). Adding a computed dependency can also immediately mark a signal as pending.</p><p>Updating a dependency can mark listeners as pending:</p><pre><code class="language-julia hljs">source_1 = Cortex.Signal(1)
source_2 = Cortex.Signal(2)

derived = Cortex.Signal() # A signal that will depend on s1 and s2

Cortex.add_dependency!(derived, source_1)
Cortex.add_dependency!(derived, source_2)

Cortex.is_pending(derived) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p><code>derived</code> is pending because both <code>source_1</code> and <code>source_2</code> have been computed and are considered fresh with respect to <code>derived</code> at the time of dependency addition. Let&#39;s try a different example:</p><pre><code class="language-julia hljs">uncomputed_source = Cortex.Signal()
derived = Cortex.Signal()

Cortex.add_dependency!(derived, uncomputed_source)

Cortex.is_pending(derived) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs">Cortex.set_value!(uncomputed_source, 1)

Cortex.is_pending(derived) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>After setting the value of <code>uncomputed_source</code>, <code>derived</code> becomes pending because <code>uncomputed_source</code> is now computed and fresh with respect to <code>derived</code>.</p><h3 id="Setting-Values"><a class="docs-heading-anchor" href="#Setting-Values">Setting Values</a><a id="Setting-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Values" title="Permalink"></a></h3><p>Use <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a> to update a signal&#39;s value. It also consumes the &#39;freshness&#39; of its own dependencies and updates the &#39;fresh&#39; and &#39;computed&#39; status for its listeners, potentially marking them as pending.</p><div class="admonition is-info" id="Note-8730475ba03bc41d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8730475ba03bc41d" title="Permalink"></a></header><div class="admonition-body"><p>Normally, it is implied that <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a> must be called only on signals that are pending. Also see the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function for a more general way to update signal values.</p></div></div><pre><code class="language-julia hljs">source  = Cortex.Signal(1)
derived = Cortex.Signal()

Cortex.add_dependency!(derived, source)

Cortex.is_pending(derived), Cortex.is_computed(derived)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, false)</code></pre><pre><code class="language-julia hljs">Cortex.set_value!(derived, 99.0)</code></pre><pre><code class="language-julia hljs">Cortex.get_value(derived)   # 99.0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">99.0</code></pre><pre><code class="language-julia hljs">Cortex.is_pending(derived), Cortex.is_computed(derived) # false, true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(false, true)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.set_value!-Tuple{Cortex.Signal, Any}" href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>Cortex.set_value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_value!(s::Signal, value::Any)</code></pre><p>Set the <code>value</code> of the signal <code>s</code>. Notifies all the active listeners of the signal.</p><div class="admonition is-info" id="Note-ed8bcad28e9d71ee"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ed8bcad28e9d71ee" title="Permalink"></a></header><div class="admonition-body"><p>This function is not a part of the public API.  Additionally, it is implied that <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a> must be called only on signals that are pending. Use <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> for a more general way to update signal values.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L198-L208">source</a></section></article><h3 id="Computing-Signal-Values"><a class="docs-heading-anchor" href="#Computing-Signal-Values">Computing Signal Values</a><a id="Computing-Signal-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Signal-Values" title="Permalink"></a></h3><p>To compute a signal, use the <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a> function, providing a strategy (often a simple function) to calculate the new value based on dependencies. Computing a signal typically clears its pending state.</p><div class="admonition is-info" id="Note-b415e8a5c42b35d2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b415e8a5c42b35d2" title="Permalink"></a></header><div class="admonition-body"><p>By default, <code>compute!</code> throws an <code>ArgumentError</code> if called on a signal that is not pending (<a href="#Cortex.is_pending-Tuple{Cortex.Signal}"><code>is_pending</code></a> returns <code>false</code>). You can override this check using the <code>force=true</code> keyword argument.</p></div></div><pre><code class="language-julia hljs">signal_1 = Cortex.Signal(1)
signal_2 = Cortex.Signal(41)

signal_to_be_computed = Cortex.Signal()

Cortex.add_dependency!(signal_to_be_computed, signal_1)
Cortex.add_dependency!(signal_to_be_computed, signal_2)

Cortex.is_pending(signal_to_be_computed) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs"># Define a strategy (a function) to compute the value
compute_sum = (signal, deps) -&gt; sum(Cortex.get_value, deps)

# Apply the strategy using compute!
Cortex.compute!(compute_sum, signal_to_be_computed)</code></pre><pre><code class="language-julia hljs">Cortex.get_value(signal_to_be_computed) # 42</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">42</code></pre><pre><code class="language-julia hljs">Cortex.is_pending(signal_to_be_computed) # false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><pre><code class="language-julia hljs"># This would normally throw an error:
# compute!(compute_sum, signal_to_be_computed)

# But we can force it:
Cortex.compute!(compute_sum, signal_to_be_computed; force=true)

Cortex.get_value(signal_to_be_computed) # 42</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">42</code></pre><h3 id="Custom-Compute-Strategies"><a class="docs-heading-anchor" href="#Custom-Compute-Strategies">Custom Compute Strategies</a><a id="Custom-Compute-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Compute-Strategies" title="Permalink"></a></h3><p>You can define custom types and methods to implement more complex computation logic beyond simple functions. This allows strategies to hold their own state or parameters.</p><p>First, define a struct for your strategy:</p><pre><code class="language-julia hljs">struct CustomStrategy
    multiplier::Int
end</code></pre><p>Then, implement the <a href="#Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}"><code>compute_value!</code></a> method for your strategy type:</p><pre><code class="language-julia hljs">function Cortex.compute_value!(strategy::CustomStrategy, signal::Cortex.Signal, dependencies)
    # Example: Use signal&#39;s metadata if available
    meta = Cortex.get_metadata(signal)
    base_sum = sum(Cortex.get_value, dependencies)
    offset = meta isa Dict &amp;&amp; haskey(meta, :offset) ? meta[:offset] : 0
    return strategy.multiplier * base_sum + offset
end</code></pre><p>Now, you can use this strategy with your signals:</p><pre><code class="language-julia hljs">strategy = CustomStrategy(2)

signal_with_meta = Cortex.Signal(metadata=Dict(:offset =&gt; 10))

Cortex.add_dependency!(signal_with_meta, signal_1)
Cortex.add_dependency!(signal_with_meta, signal_2)

Cortex.compute!(strategy, signal_with_meta)

Cortex.get_value(signal_with_meta) # 94</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">94</code></pre><pre><code class="language-julia hljs">Cortex.compute!(CustomStrategy(3), signal_with_meta; force=true)

Cortex.get_value(signal_with_meta) # 136</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">136</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.compute!-Tuple{Any, Cortex.Signal}" href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>Cortex.compute!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute!(s::Signal, strategy; force::Bool = false, skip_if_no_listeners::Bool = true)</code></pre><p>Compute the value of the signal <code>s</code> using the given <code>strategy</code>.  The strategy must implement <a href="#Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}"><code>compute_value!</code></a> method. If the strategy is a function, it is assumed to be a function that takes the signal and a vector of signal&#39;s dependencies as arguments and returns a value. Be sure to call <code>compute!</code> only on signals that are pending.  Calling <code>compute!</code> on a non-pending signal will result in an error.</p><p>When <code>skip_if_no_listeners</code> is set to <code>true</code>, the function will not compute the signal if it has no listeners. If <code>skip_if_no_listeners</code> is set to <code>false</code>, the function will compute the signal even if it has no listeners. This is useful for signals that are computed on demand with no listeners.</p><p>Keyword Arguments:</p><ul><li><code>force::Bool = false</code>: If <code>true</code>, the signal will be computed even if it is not pending.</li><li><code>skip_if_no_listeners::Bool = true</code>: If <code>true</code>, the function will not compute the signal if it has no listeners.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L351-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}" href="#Cortex.compute_value!-Tuple{Any, Cortex.Signal, Vector{Cortex.Signal}}"><code>Cortex.compute_value!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_value!(strategy, signal, dependencies)</code></pre><p>Compute the value of the signal <code>signal</code> using the given <code>strategy</code>. The strategy must implement this method. See also <a href="#Cortex.compute!-Tuple{Any, Cortex.Signal}"><code>compute!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L389-L394">source</a></section></article><h3 id="Processing-Dependency-Trees-of-Signals-with-process_dependencies!"><a class="docs-heading-anchor" href="#Processing-Dependency-Trees-of-Signals-with-process_dependencies!">Processing Dependency Trees of Signals with <code>process_dependencies!</code></a><a id="Processing-Dependency-Trees-of-Signals-with-process_dependencies!-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-Dependency-Trees-of-Signals-with-process_dependencies!" title="Permalink"></a></h3><p>The <code>process_dependencies!</code> function provides a powerful way to traverse and operate on the dependency graph of a signal. It&#39;s particularly useful for scenarios where you need more control over how dependencies are evaluated or when implementing custom update schedulers.</p><p>The function recursively applies a user-defined function <code>f</code> to each dependency. <code>f</code> should return <code>true</code> if it considers the dependency &quot;processed&quot; by its own logic, and <code>false</code> otherwise. <code>process_dependencies!</code> propagates this status and can optionally retry processing an intermediate dependency if its own sub-dependencies were processed.</p><p><strong>Use Cases:</strong></p><ul><li>Implementing custom evaluation orders for signals.</li><li>Performing actions on dependencies before computing a parent signal.</li><li>Debugging or inspecting the state of a signal&#39;s dependency graph.</li></ul><p><strong>Conceptual Example:</strong></p><p>Imagine you want to traverse the dependency graph of a signal and you want to log which ones were already computed and which ones are not.</p><pre><code class="language-julia hljs">signal1 = Cortex.Signal(1; metadata = :signal1) # computed
signal2 = Cortex.Signal(; metadata = :signal2)  # not computed
signal3 = Cortex.Signal(3; metadata = :signal3)  # computed

intermediate_signal = Cortex.Signal(metadata = :intermediate_signal)

Cortex.add_dependency!(intermediate_signal, signal2)
Cortex.add_dependency!(intermediate_signal, signal3)

derived = Cortex.Signal(metadata = :derived)

Cortex.add_dependency!(derived, signal1)
Cortex.add_dependency!(derived, intermediate_signal; intermediate=true)

function my_processing_function(dependency_signal::Cortex.Signal)
    if !Cortex.is_computed(dependency_signal)
        println(&quot;The dependency signal: &quot;, Cortex.get_metadata(dependency_signal), &quot; is not computed&quot;)
    else
        println(&quot;The dependency signal: &quot;, Cortex.get_metadata(dependency_signal), &quot; is computed. The value is: &quot;, Cortex.get_value(dependency_signal))
    end
    # always return false to process all the dependencies
    return false
end

Cortex.process_dependencies!(my_processing_function, derived)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">The dependency signal: signal1 is computed. The value is: 1
The dependency signal: intermediate_signal is not computed
The dependency signal: signal2 is not computed
The dependency signal: signal3 is computed. The value is: 3</code></pre><p>This example illustrates how you can inject custom logic into the dependency traversal. The actual computation or state change would happen within <code>my_processing_function</code>. For example, here how can we <code>compute!</code> the signal if it is not computed:</p><pre><code class="language-julia hljs">signal1 = Cortex.Signal(1; metadata = :signal1)
signal2 = Cortex.Signal(2; metadata = :signal2)
signal3 = Cortex.Signal(3; metadata = :signal3)

intermediate_signal = Cortex.Signal(metadata = :intermediate_signal)

Cortex.add_dependency!(intermediate_signal, signal2)
Cortex.add_dependency!(intermediate_signal, signal3)

derived = Cortex.Signal(metadata = :derived)

Cortex.add_dependency!(derived, signal1)
Cortex.add_dependency!(derived, intermediate_signal; intermediate=true)

function compute_if_not_computed(signal::Cortex.Signal)
    if Cortex.is_pending(signal)
        println(&quot;Computing the signal: &quot;, Cortex.get_metadata(signal))
        Cortex.compute!((signal, deps) -&gt; sum(Cortex.get_value, deps), signal)
        return true
    end
    return false
end

Cortex.process_dependencies!(compute_if_not_computed, derived; retry = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Computing the signal: intermediate_signal</code></pre><p>Now, since we processed and computed all the dependencies, the derived signal should be in the pending state:</p><pre><code class="language-julia hljs">Cortex.is_pending(derived) # true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Which we can also compute using the same function:</p><pre><code class="language-julia hljs">compute_if_not_computed(derived)

Cortex.get_value(derived) # 6</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}" href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>Cortex.process_dependencies!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_dependencies!(f::F, signal::Signal; retry::Bool = false) where {F}</code></pre><p>Recursively processes the dependencies of a <code>signal</code> using a provided function <code>f</code>.</p><p>The function <code>f</code> is applied to each direct dependency of <code>signal</code>. If a dependency is marked as <code>intermediate</code>  and <code>f</code> returns <code>false</code> for it (indicating it was not processed by <code>f</code> according to its own criteria),  <code>process_dependencies!</code> will then be called recursively on that intermediate dependency.</p><p>Arguments:</p><ul><li><code>f::F</code>: A function (or callable object) that takes a <code>Signal</code> (a dependency) as an argument and returns a <code>Bool</code>.  It should return <code>true</code> if it considered the dependency processed, and <code>false</code> otherwise. The specific logic  for this determination (e.g., checking if a dependency is pending before processing) is up to <code>f</code>.</li><li><code>signal::Signal</code>: The signal whose dependencies are to be processed.</li></ul><p>Keyword Arguments:</p><ul><li><code>retry::Bool = false</code>: If <code>true</code>, and an intermediate dependency&#39;s own sub-dependencies were processed  (i.e., the recursive call to <code>process_dependencies!</code> for the intermediate dependency returned <code>true</code>  because <code>f</code> returned <code>true</code> for at least one sub-dependency), then the function <code>f</code> will be called  again on the intermediate dependency itself. This allows for a second attempt by <code>f</code> to process the  intermediate dependency after its own prerequisites might have been met by processing its sub-dependencies.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: <code>true</code> if the function <code>f</code> returned <code>true</code> for at least one dependency encountered (either directly  or recursively through an intermediate one). Returns <code>false</code> if <code>f</code> returned <code>false</code> for all dependencies  it was applied to.</li></ul><p>Behavior Details:</p><ul><li>For each dependency of <code>signal</code>:<ol><li><code>f(dependency)</code> is called.</li><li>If <code>f(dependency)</code> returns <code>true</code>, this dependency is considered processed by <code>f</code>.</li><li>If <code>f(dependency)</code> returns <code>false</code> AND the dependency is marked as <code>intermediate</code>:  a. <code>process_dependencies!(f, dependency; retry=retry)</code> is called recursively.  b. If this recursive call returns <code>true</code> (meaning <code>f</code> processed at least one sub-dependency of the      intermediate one) AND <code>retry</code> is <code>true</code>, then <code>f(dependency)</code> is called again.</li></ol></li><li>The function tracks whether <code>f</code> returned <code>true</code> for any dependency it was applied to, at any level of  recursion (for intermediate dependencies) or direct application, and returns this aggregated result.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ReactiveBayes/Cortex.jl/blob/c59f9868f188a8012386f25876ea6b11faf849d6/src/signal.jl#L405-L442">source</a></section></article><h2 id="Internal-Mechanics-(For-Developers)"><a class="docs-heading-anchor" href="#Internal-Mechanics-(For-Developers)">Internal Mechanics (For Developers)</a><a id="Internal-Mechanics-(For-Developers)-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Mechanics-(For-Developers)" title="Permalink"></a></h2><div class="admonition is-warning" id="Advanced-Topic-c07d8ab609b3d9a6"><header class="admonition-header">Advanced Topic<a class="admonition-anchor" href="#Advanced-Topic-c07d8ab609b3d9a6" title="Permalink"></a></header><div class="admonition-body"><p>The details in this section are primarily for developers working on or extending Cortex.jl&#39;s core reactivity. Regular users do not typically need to interact with these internal components directly.</p></div></div><p>The efficient tracking of dependency states (intermediate, weak, computed, and fresh) is managed internally by a structure associated with each signal, <code>SignalDependenciesProps</code>.</p><h3 id="SignalDependenciesProps:-Packed-Dependency-Information"><a class="docs-heading-anchor" href="#SignalDependenciesProps:-Packed-Dependency-Information"><code>SignalDependenciesProps</code>: Packed Dependency Information</a><a id="SignalDependenciesProps:-Packed-Dependency-Information-1"></a><a class="docs-heading-anchor-permalink" href="#SignalDependenciesProps:-Packed-Dependency-Information" title="Permalink"></a></h3><p>To minimize overhead, the properties for each dependency are bit-packed into 4-bit &quot;nibbles&quot; within <code>UInt64</code> chunks. This allows a single <code>UInt64</code> to hold status information for 16 dependencies. The bits are assigned as follows (from LSB to MSB):</p><ul><li><strong>Bit 1 (<code>0x1</code>): <code>IsIntermediate</code></strong>: True if the dependency is an intermediate one for processing logic (see <a href="#Cortex.process_dependencies!-Tuple{Any, Cortex.Signal}"><code>process_dependencies!</code></a>).</li><li><strong>Bit 2 (<code>0x2</code>): <code>IsWeak</code></strong>: True if the dependency is weak.</li><li><strong>Bit 3 (<code>0x4</code>): <code>IsComputed</code></strong>: True if the dependency itself holds a computed value.</li><li><strong>Bit 4 (<code>0x8</code>): <code>IsFresh</code></strong>: True if the dependency has provided a new value that has not yet been consumed by the current signal&#39;s computation.</li></ul><h3 id="Determining-Pending-State"><a class="docs-heading-anchor" href="#Determining-Pending-State">Determining Pending State</a><a id="Determining-Pending-State-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-Pending-State" title="Permalink"></a></h3><p>The <a href="#Cortex.is_pending-Tuple{Cortex.Signal}"><code>is_pending(signal)</code></a> function relies on an internal check (currently <code>is_meeting_pending_criteria</code>) that operates on these packed properties. A signal is considered to meet the criteria to become pending if, for <strong>every</strong> one of its dependencies:</p><p><code>(IsComputed AND (IsWeak OR IsFresh))</code></p><p>This means:</p><ul><li>A <strong>weak</strong> dependency must simply be <code>IsComputed</code>.</li><li>A <strong>strong</strong> (non-weak) dependency must be <code>IsComputed</code> AND <code>IsFresh</code>.</li></ul><p>When <a href="#Cortex.set_value!-Tuple{Cortex.Signal, Any}"><code>set_value!</code></a> is called on a signal:</p><ol><li>The <code>IsFresh</code> flags for all its own dependencies are cleared (as their values have now been &quot;used&quot;).</li><li>For each of its listeners, the original signal (which just got a new value) is marked as <code>IsComputed</code> and <code>IsFresh</code> in that listener&#39;s dependency properties. This, in turn, can cause the listener to become pending.</li></ol><p>This bit-packed approach allows for efficient batch updates and checks across many dependencies.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../inference/">Probabilistic Inference with Cortex »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.3 on <span class="colophon-date" title="Thursday 15 May 2025 13:03">Thursday 15 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
